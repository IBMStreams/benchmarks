/*
===============================================================================
                       RACING IBM STREAMS ON LINEAR ROAD
                       *********************************
This file contains the IBM Streams code for an implementation of the
Linear Road analytics which offers one particular method to evaluate a
Streaming Middleware product by measuring its key performance indicators.

Three major evaluation factors in Linear Road: 

1) Maximum data volume a Stream processing product can handle.
2) Accuracy of the results a product produces.
3) Response time in processing three different event types.

Authors of the Linear Road stress the following as the main objective of their
well conceived scenario that closely resembles certain real life situations: 

"Because most stream queries are continuous, performance metrics should be based
on response time rather than completion time. It measures how well a system can 
meet real-time query response requirements in processing high volume streaming
and historical data. It determines the L-rating of a stream processing systen
which is defined as the maximum scale factor at which the system can respond to
the specified set of continuous and historical queries while meeting their
response time and accuracy requirements. It is assumed that the scenario will be
run with increasingly larger scale factors until one is found for which the
requirements cannot be met."

In order to understand the code below, one should have a good grounding in
the imaginary scenario on which the Linear Road is based upon.
If necessary, please read about that first before proceeding with the code below.

http://www.cs.brandeis.edu/~linearroad/ 

NOTE
----
This is one of many possible ways in which the Linear Road challenge can be 
implemented using the IBM Streams product. When tasked with this same LR problem,
other IBM Streams enthusiasts may have followed a different design approach to show 
either an inferior or a superior performance of IBM Streams for this use case.
It would be nice to see such alternative improved IBM Streams-->Linear Road solutions.

First created on: Aug/19/2015
Last modified on: Oct/14/2015
===============================================================================
*/

<% # Switch to Perl scripting mode
	use integer;
	print "// Perl Arguments in effect for mixed-mode processing\n";
	my $argCnt = @ARGV;
	print "// Argument count: ", $argCnt, "\n";
	my $argIdx;
	for ($argIdx = 0; $argIdx < $argCnt; $argIdx++) {
		print "// \$ARGV\[", $argIdx, "\]\:", $ARGV[$argIdx], "\n";
	}
%>

<%
	# Set the number of type 0 position report event processor operator instances we will need.
	# In the Linear Road scenario, expressways are bidirectional. Hence, user must always provide it as
	# TOTAL_EXPRESSWAYS * 2 to have that many operator instances for supporting both directions.
	my $totalNumberOfExpressways = 100;
	my $totalPositionReportEngines = $totalNumberOfExpressways * 2;
	
	# Number of position report processors that will be fused into a single PE.
	my $totalNumberOfExpresswaysInFusedPe = 5;
	my $totalNumberOfPositionReportEnginesInFusedPe = $totalNumberOfExpresswaysInFusedPe * 2; 
%>

namespace com.ibm.streamsx.lr;

// Let the compiler know about the other composites and toolkits the code below depends on.
// Commonly used data types and SPL functions are available in this namespace.
use com.ibm.streamsx.lr.common::*;
// Following are for the DPS toolkit namespaces that provide the functions we will use in the code below.
use com.ibm.streamsx.lock.distributed::*;
use com.ibm.streamsx.store.distributed::*;
// Declare the use of the messaging toolkit.
use com.ibm.streamsx.messaging.kafka::*;

// This is the main composite a.k.a entry point for this application.
// NOTE: This is a special version created to make the 50 expressways (1 Billion messages) work correctly.
//       Search for "100x version" in this file for specific changes made.
//       For 1x, 2x, 5x, 10x, 15x, 20x and 25x, please use a different version from the back up (rc11 from Oct/13/2015).
composite LinearRoad {
	// Declare the constants that will be used in the code below.
	param
		// expression<rstring> $LINEAR_ROAD_DATA_FILE_NAME : getSubmissionTimeValue("DataFile", "/datadrive2/lr-input/Walmart-Test-Data/1xway/ten-minutes-test-cardatapoints.out");
		expression<rstring> $LINEAR_ROAD_DATA_FILE_NAME : getSubmissionTimeValue("DataFile", "/datadrive2/lr-input/Walmart-Test-Data/1xway/1.xway.final.dat");
		expression<rstring> $LINEAR_ROAD_FINAL_TYPE0_OUTPUT_FILE : getSubmissionTimeValue("Type0OutputFile", "/datadrive/lr-output/0-toll-notifications.txt");
		expression<rstring> $LINEAR_ROAD_FINAL_TYPE1_OUTPUT_FILE : getSubmissionTimeValue("Type1OutputFile", "/datadrive/lr-output/1-accident-alerts.txt");
		expression<rstring> $LINEAR_ROAD_FINAL_TYPE2_OUTPUT_FILE : getSubmissionTimeValue("Type2OutputFile", "/datadrive/lr-output/2-account-balances.txt");
		expression<rstring> $LINEAR_ROAD_FINAL_TYPE3_OUTPUT_FILE : getSubmissionTimeValue("Type3OutputFile", "/datadrive/lr-output/3-daily-expenditures.txt");
		// Identifiers for different event types.
		expression<int32> $POSTION_REPORT_EVENT : 0;
		expression<int32> $ACCOUNT_BALANCE_QUERY_EVENT : 2;
		expression<int32> $DAILY_EXPENDITURE_QUERY_EVENT : 3;
		// Linear road messaging topic name.
		expression<rstring> $LR_KAFKA_TOPIC_NAME : getSubmissionTimeValue("KafkaTopicName", "IBM-Streams-Linear-Road");
		expression<float64> $INIT_DELAY_FOR_THIRTY_DAYS : 2592000.00;
		expression<float64> $INIT_DELAY_VALUE : (float64)getSubmissionTimeValue("InitDelay", "45.00");

	// Main application graph begins here.
	graph
// ****************** Data Feeder logic begins here ******************
		// Ingest the Linear Road analytics data as they are getting generated by
		// the data feeder component. This is a C++ operator that wraps the
		// data feeder code provided by a group of academicians from the Linear Road team.
		//
		// Our C++ DataFeeder operator can emit events either as readily formatted tuples or it can
		// emit events as CSV formatted string which is suitable for a kafka messaging system.
		//
		// If we have to feed the data as fast as possible instead of the interposed delays between
		// the events as done by the MIT/Brown written data feeder code, we can configure this operator to
		// not emit any events and use a FileSource operator below to read the data from the file on our own.
		// We are going to have 10 copies of the Data feeder each sending data only for 10 expressways. (100x version)
		(stream<LinearRoadEventType> LREventViaTcp1;
		 stream<LinearRoadEventCsvType> LREventToKafkaTopic1) = DataFeeder() {
			param
				// Start sending data feeds after this one time delay. That will give
				// all the distributed operators in this application topology to get
				// connected properly on time before the data hits all of them.
				initDelay: (uint32)$INIT_DELAY_VALUE;
				dataFile: $LINEAR_ROAD_DATA_FILE_NAME;
				// Our LR data feeder can send the data either directly to the rest of the 
				// application topology via tcp (synchronously) or indirectly via 
				// a kafka messaging layer (asynchronously).
				// If we want to feed the LR events as fast as possible instead of the 
				// interposed delays as done by the LR data feeder, we can configure below as none.
				// Then, we must adjust the FileSource operator below to read from the data file very fast.
				//
				// Possible values: tcp, kafka, none
				dataReceiver: tcp;
				// 200x version
				startingExpressway: 0u;
				endingExpressway: 9u;
				
			config
				// Place the data ingestion operator on a particular machine where the LR input files are stored.
				// placement: host(lrPool[2]), partitionColocation("LR-DataFeeder");
				placement: host(lrPool[0]), partitionColocation("LR-DataFeeder1");
		}

		// 200x version
		(stream<LinearRoadEventType> LREventViaTcp2;
		 stream<LinearRoadEventCsvType> LREventToKafkaTopic2) = DataFeeder() {
			param
				// Start sending data feeds after this one time delay. That will give
				// all the distributed operators in this application topology to get
				// connected properly on time before the data hits all of them.
				initDelay: (uint32)$INIT_DELAY_VALUE;
				dataFile: $LINEAR_ROAD_DATA_FILE_NAME;
				// Our LR data feeder can send the data either directly to the rest of the 
				// application topology via tcp (synchronously) or indirectly via 
				// a kafka messaging layer (asynchronously).
				// If we want to feed the LR events as fast as possible instead of the 
				// interposed delays as done by the LR data feeder, we can configure below as none.
				// Then, we must adjust the FileSource operator below to read from the data file very fast.
				//
				// Possible values: tcp, kafka, none
				dataReceiver: tcp;
				// 200x version
				startingExpressway: 10u;
				endingExpressway: 19u;
				
			config
				// Place the data ingestion operator on a particular machine where the LR input files are stored.
				// placement: partitionColocation("LR-DataFeeder");
				placement: host(lrPool[1]), partitionColocation("LR-DataFeeder2");
		}

		// 200x version
		(stream<LinearRoadEventType> LREventViaTcp3;
		 stream<LinearRoadEventCsvType> LREventToKafkaTopic3) = DataFeeder() {
			param
				// Start sending data feeds after this one time delay. That will give
				// all the distributed operators in this application topology to get
				// connected properly on time before the data hits all of them.
				initDelay: (uint32)$INIT_DELAY_VALUE;
				dataFile: $LINEAR_ROAD_DATA_FILE_NAME;
				// Our LR data feeder can send the data either directly to the rest of the 
				// application topology via tcp (synchronously) or indirectly via 
				// a kafka messaging layer (asynchronously).
				// If we want to feed the LR events as fast as possible instead of the 
				// interposed delays as done by the LR data feeder, we can configure below as none.
				// Then, we must adjust the FileSource operator below to read from the data file very fast.
				//
				// Possible values: tcp, kafka, none
				dataReceiver: tcp;
				// 200x version
				startingExpressway: 20u;
				endingExpressway: 29u;
				
			config
				// Place the data ingestion operator on a particular machine where the LR input files are stored.
				// placement: partitionColocation("LR-DataFeeder");
				placement: host(lrPool[1]), partitionColocation("LR-DataFeeder3");
		}

		// 200x version
		(stream<LinearRoadEventType> LREventViaTcp4;
		 stream<LinearRoadEventCsvType> LREventToKafkaTopic4) = DataFeeder() {
			param
				// Start sending data feeds after this one time delay. That will give
				// all the distributed operators in this application topology to get
				// connected properly on time before the data hits all of them.
				initDelay: (uint32)$INIT_DELAY_VALUE;
				dataFile: $LINEAR_ROAD_DATA_FILE_NAME;
				// Our LR data feeder can send the data either directly to the rest of the 
				// application topology via tcp (synchronously) or indirectly via 
				// a kafka messaging layer (asynchronously).
				// If we want to feed the LR events as fast as possible instead of the 
				// interposed delays as done by the LR data feeder, we can configure below as none.
				// Then, we must adjust the FileSource operator below to read from the data file very fast.
				//
				// Possible values: tcp, kafka, none
				dataReceiver: tcp;
				// 200x version
				startingExpressway: 30u;
				endingExpressway: 39u;
				
			config
				// Place the data ingestion operator on a particular machine where the LR input files are stored.
				// placement: partitionColocation("LR-DataFeeder");
				placement: host(lrPool[3]), partitionColocation("LR-DataFeeder4");
		}

		// 200x version
		(stream<LinearRoadEventType> LREventViaTcp5;
		 stream<LinearRoadEventCsvType> LREventToKafkaTopic5) = DataFeeder() {
			param
				// Start sending data feeds after this one time delay. That will give
				// all the distributed operators in this application topology to get
				// connected properly on time before the data hits all of them.
				initDelay: (uint32)$INIT_DELAY_VALUE;
				dataFile: $LINEAR_ROAD_DATA_FILE_NAME;
				// Our LR data feeder can send the data either directly to the rest of the 
				// application topology via tcp (synchronously) or indirectly via 
				// a kafka messaging layer (asynchronously).
				// If we want to feed the LR events as fast as possible instead of the 
				// interposed delays as done by the LR data feeder, we can configure below as none.
				// Then, we must adjust the FileSource operator below to read from the data file very fast.
				//
				// Possible values: tcp, kafka, none
				dataReceiver: tcp;
				// 200x version
				startingExpressway: 40u;
				endingExpressway: 49u;
				
			config
				// Place the data ingestion operator on a particular machine where the LR input files are stored.
				// placement: partitionColocation("LR-DataFeeder");
				placement: host(lrPool[4]), partitionColocation("LR-DataFeeder5");
		}
		
		// 200x version
		(stream<LinearRoadEventType> LREventViaTcp6;
		 stream<LinearRoadEventCsvType> LREventToKafkaTopic6) = DataFeeder() {
			param
				// Start sending data feeds after this one time delay. That will give
				// all the distributed operators in this application topology to get
				// connected properly on time before the data hits all of them.
				initDelay: (uint32)$INIT_DELAY_VALUE;
				dataFile: $LINEAR_ROAD_DATA_FILE_NAME;
				// Our LR data feeder can send the data either directly to the rest of the 
				// application topology via tcp (synchronously) or indirectly via 
				// a kafka messaging layer (asynchronously).
				// If we want to feed the LR events as fast as possible instead of the 
				// interposed delays as done by the LR data feeder, we can configure below as none.
				// Then, we must adjust the FileSource operator below to read from the data file very fast.
				//
				// Possible values: tcp, kafka, none
				dataReceiver: tcp;
				// 200x version
				startingExpressway: 50u;
				endingExpressway: 59u;
				
			config
				// Place the data ingestion operator on a particular machine where the LR input files are stored.
				// placement: partitionColocation("LR-DataFeeder");
				placement: host(lrPool[0]), partitionColocation("LR-DataFeeder6");
		}		

		// 200x version
		(stream<LinearRoadEventType> LREventViaTcp7;
		 stream<LinearRoadEventCsvType> LREventToKafkaTopic7) = DataFeeder() {
			param
				// Start sending data feeds after this one time delay. That will give
				// all the distributed operators in this application topology to get
				// connected properly on time before the data hits all of them.
				initDelay: (uint32)$INIT_DELAY_VALUE;
				dataFile: $LINEAR_ROAD_DATA_FILE_NAME;
				// Our LR data feeder can send the data either directly to the rest of the 
				// application topology via tcp (synchronously) or indirectly via 
				// a kafka messaging layer (asynchronously).
				// If we want to feed the LR events as fast as possible instead of the 
				// interposed delays as done by the LR data feeder, we can configure below as none.
				// Then, we must adjust the FileSource operator below to read from the data file very fast.
				//
				// Possible values: tcp, kafka, none
				dataReceiver: tcp;
				// 200x version
				startingExpressway: 60u;
				endingExpressway: 69u;
				
			config
				// Place the data ingestion operator on a particular machine where the LR input files are stored.
				// placement: partitionColocation("LR-DataFeeder");
				placement: host(lrPool[1]), partitionColocation("LR-DataFeeder7");
		}
		
		// 200x version
		(stream<LinearRoadEventType> LREventViaTcp8;
		 stream<LinearRoadEventCsvType> LREventToKafkaTopic8) = DataFeeder() {
			param
				// Start sending data feeds after this one time delay. That will give
				// all the distributed operators in this application topology to get
				// connected properly on time before the data hits all of them.
				initDelay: (uint32)$INIT_DELAY_VALUE;
				dataFile: $LINEAR_ROAD_DATA_FILE_NAME;
				// Our LR data feeder can send the data either directly to the rest of the 
				// application topology via tcp (synchronously) or indirectly via 
				// a kafka messaging layer (asynchronously).
				// If we want to feed the LR events as fast as possible instead of the 
				// interposed delays as done by the LR data feeder, we can configure below as none.
				// Then, we must adjust the FileSource operator below to read from the data file very fast.
				//
				// Possible values: tcp, kafka, none
				dataReceiver: tcp;
				// 200x version
				startingExpressway: 70u;
				endingExpressway: 79u;
				
			config
				// Place the data ingestion operator on a particular machine where the LR input files are stored.
				// placement: partitionColocation("LR-DataFeeder");
				placement: host(lrPool[3]), partitionColocation("LR-DataFeeder8");
		}
		
		// 200x version
		(stream<LinearRoadEventType> LREventViaTcp9;
		 stream<LinearRoadEventCsvType> LREventToKafkaTopic9) = DataFeeder() {
			param
				// Start sending data feeds after this one time delay. That will give
				// all the distributed operators in this application topology to get
				// connected properly on time before the data hits all of them.
				initDelay: (uint32)$INIT_DELAY_VALUE;
				dataFile: $LINEAR_ROAD_DATA_FILE_NAME;
				// Our LR data feeder can send the data either directly to the rest of the 
				// application topology via tcp (synchronously) or indirectly via 
				// a kafka messaging layer (asynchronously).
				// If we want to feed the LR events as fast as possible instead of the 
				// interposed delays as done by the LR data feeder, we can configure below as none.
				// Then, we must adjust the FileSource operator below to read from the data file very fast.
				//
				// Possible values: tcp, kafka, none
				dataReceiver: tcp;
				// 200x version
				startingExpressway: 80u;
				endingExpressway: 89u;
				
			config
				// Place the data ingestion operator on a particular machine where the LR input files are stored.
				// placement: partitionColocation("LR-DataFeeder");
				placement: host(lrPool[4]), partitionColocation("LR-DataFeeder9");
		}		
		
		// 200x version
		(stream<LinearRoadEventType> LREventViaTcp10;
		 stream<LinearRoadEventCsvType> LREventToKafkaTopic10) = DataFeeder() {
			param
				// Start sending data feeds after this one time delay. That will give
				// all the distributed operators in this application topology to get
				// connected properly on time before the data hits all of them.
				initDelay: (uint32)$INIT_DELAY_VALUE;
				dataFile: $LINEAR_ROAD_DATA_FILE_NAME;
				// Our LR data feeder can send the data either directly to the rest of the 
				// application topology via tcp (synchronously) or indirectly via 
				// a kafka messaging layer (asynchronously).
				// If we want to feed the LR events as fast as possible instead of the 
				// interposed delays as done by the LR data feeder, we can configure below as none.
				// Then, we must adjust the FileSource operator below to read from the data file very fast.
				//
				// Possible values: tcp, kafka, none
				dataReceiver: tcp;
				// 200x version
				startingExpressway: 90u;
				endingExpressway: 99u;
				
			config
				// Place the data ingestion operator on a particular machine where the LR input files are stored.
				// placement: partitionColocation("LR-DataFeeder");
				placement: host(lrPool[4]), partitionColocation("LR-DataFeeder10");
		}
		
		// 200x version
		(stream<LinearRoadEventType> LREventViaTcp11;
		 stream<LinearRoadEventCsvType> LREventToKafkaTopic11) = DataFeeder() {
			param
				// Start sending data feeds after this one time delay. That will give
				// all the distributed operators in this application topology to get
				// connected properly on time before the data hits all of them.
				initDelay: (uint32)$INIT_DELAY_VALUE;
				dataFile: $LINEAR_ROAD_DATA_FILE_NAME;
				// Our LR data feeder can send the data either directly to the rest of the 
				// application topology via tcp (synchronously) or indirectly via 
				// a kafka messaging layer (asynchronously).
				// If we want to feed the LR events as fast as possible instead of the 
				// interposed delays as done by the LR data feeder, we can configure below as none.
				// Then, we must adjust the FileSource operator below to read from the data file very fast.
				//
				// Possible values: tcp, kafka, none
				dataReceiver: tcp;
				// 200x version
				startingExpressway: 100u;
				endingExpressway: 109u;
				
			config
				// Place the data ingestion operator on a particular machine where the LR input files are stored.
				// placement: partitionColocation("LR-DataFeeder");
				placement: host(lrPool[0]), partitionColocation("LR-DataFeeder11");
		}

		// 200x version
		(stream<LinearRoadEventType> LREventViaTcp12;
		 stream<LinearRoadEventCsvType> LREventToKafkaTopic12) = DataFeeder() {
			param
				// Start sending data feeds after this one time delay. That will give
				// all the distributed operators in this application topology to get
				// connected properly on time before the data hits all of them.
				initDelay: (uint32)$INIT_DELAY_VALUE;
				dataFile: $LINEAR_ROAD_DATA_FILE_NAME;
				// Our LR data feeder can send the data either directly to the rest of the 
				// application topology via tcp (synchronously) or indirectly via 
				// a kafka messaging layer (asynchronously).
				// If we want to feed the LR events as fast as possible instead of the 
				// interposed delays as done by the LR data feeder, we can configure below as none.
				// Then, we must adjust the FileSource operator below to read from the data file very fast.
				//
				// Possible values: tcp, kafka, none
				dataReceiver: tcp;
				// 200x version
				startingExpressway: 110u;
				endingExpressway: 119u;
				
			config
				// Place the data ingestion operator on a particular machine where the LR input files are stored.
				// placement: partitionColocation("LR-DataFeeder");
				placement: host(lrPool[1]), partitionColocation("LR-DataFeeder12");
		}
		
		// 200x version
		(stream<LinearRoadEventType> LREventViaTcp13;
		 stream<LinearRoadEventCsvType> LREventToKafkaTopic13) = DataFeeder() {
			param
				// Start sending data feeds after this one time delay. That will give
				// all the distributed operators in this application topology to get
				// connected properly on time before the data hits all of them.
				initDelay: (uint32)$INIT_DELAY_VALUE;
				dataFile: $LINEAR_ROAD_DATA_FILE_NAME;
				// Our LR data feeder can send the data either directly to the rest of the 
				// application topology via tcp (synchronously) or indirectly via 
				// a kafka messaging layer (asynchronously).
				// If we want to feed the LR events as fast as possible instead of the 
				// interposed delays as done by the LR data feeder, we can configure below as none.
				// Then, we must adjust the FileSource operator below to read from the data file very fast.
				//
				// Possible values: tcp, kafka, none
				dataReceiver: tcp;
				// 200x version
				startingExpressway: 120u;
				endingExpressway: 129u;
				
			config
				// Place the data ingestion operator on a particular machine where the LR input files are stored.
				// placement: partitionColocation("LR-DataFeeder");
				placement: host(lrPool[3]), partitionColocation("LR-DataFeeder13");
		}

		// 200x version
		(stream<LinearRoadEventType> LREventViaTcp14;
		 stream<LinearRoadEventCsvType> LREventToKafkaTopic14) = DataFeeder() {
			param
				// Start sending data feeds after this one time delay. That will give
				// all the distributed operators in this application topology to get
				// connected properly on time before the data hits all of them.
				initDelay: (uint32)$INIT_DELAY_VALUE;
				dataFile: $LINEAR_ROAD_DATA_FILE_NAME;
				// Our LR data feeder can send the data either directly to the rest of the 
				// application topology via tcp (synchronously) or indirectly via 
				// a kafka messaging layer (asynchronously).
				// If we want to feed the LR events as fast as possible instead of the 
				// interposed delays as done by the LR data feeder, we can configure below as none.
				// Then, we must adjust the FileSource operator below to read from the data file very fast.
				//
				// Possible values: tcp, kafka, none
				dataReceiver: tcp;
				// 200x version
				startingExpressway: 130u;
				endingExpressway: 139u;
				
			config
				// Place the data ingestion operator on a particular machine where the LR input files are stored.
				// placement: partitionColocation("LR-DataFeeder");
				placement: host(lrPool[3]), partitionColocation("LR-DataFeeder14");
		}

		// 200x version
		(stream<LinearRoadEventType> LREventViaTcp15;
		 stream<LinearRoadEventCsvType> LREventToKafkaTopic15) = DataFeeder() {
			param
				// Start sending data feeds after this one time delay. That will give
				// all the distributed operators in this application topology to get
				// connected properly on time before the data hits all of them.
				initDelay: (uint32)$INIT_DELAY_VALUE;
				dataFile: $LINEAR_ROAD_DATA_FILE_NAME;
				// Our LR data feeder can send the data either directly to the rest of the 
				// application topology via tcp (synchronously) or indirectly via 
				// a kafka messaging layer (asynchronously).
				// If we want to feed the LR events as fast as possible instead of the 
				// interposed delays as done by the LR data feeder, we can configure below as none.
				// Then, we must adjust the FileSource operator below to read from the data file very fast.
				//
				// Possible values: tcp, kafka, none
				dataReceiver: tcp;
				// 200x version
				startingExpressway: 140u;
				endingExpressway: 149u;
				
			config
				// Place the data ingestion operator on a particular machine where the LR input files are stored.
				// placement: partitionColocation("LR-DataFeeder");
				placement: host(lrPool[4]), partitionColocation("LR-DataFeeder15");
		}
		
		// 200x version
		(stream<LinearRoadEventType> LREventViaTcp16;
		 stream<LinearRoadEventCsvType> LREventToKafkaTopic16) = DataFeeder() {
			param
				// Start sending data feeds after this one time delay. That will give
				// all the distributed operators in this application topology to get
				// connected properly on time before the data hits all of them.
				initDelay: (uint32)$INIT_DELAY_VALUE;
				dataFile: $LINEAR_ROAD_DATA_FILE_NAME;
				// Our LR data feeder can send the data either directly to the rest of the 
				// application topology via tcp (synchronously) or indirectly via 
				// a kafka messaging layer (asynchronously).
				// If we want to feed the LR events as fast as possible instead of the 
				// interposed delays as done by the LR data feeder, we can configure below as none.
				// Then, we must adjust the FileSource operator below to read from the data file very fast.
				//
				// Possible values: tcp, kafka, none
				dataReceiver: tcp;
				// 200x version
				startingExpressway: 150u;
				endingExpressway: 159u;
				
			config
				// Place the data ingestion operator on a particular machine where the LR input files are stored.
				// placement: partitionColocation("LR-DataFeeder");
				placement: host(lrPool[0]), partitionColocation("LR-DataFeeder16");
		}		
		// 200x version
		(stream<LinearRoadEventType> LREventViaTcp17;
		 stream<LinearRoadEventCsvType> LREventToKafkaTopic17) = DataFeeder() {
			param
				// Start sending data feeds after this one time delay. That will give
				// all the distributed operators in this application topology to get
				// connected properly on time before the data hits all of them.
				initDelay: (uint32)$INIT_DELAY_VALUE;
				dataFile: $LINEAR_ROAD_DATA_FILE_NAME;
				// Our LR data feeder can send the data either directly to the rest of the 
				// application topology via tcp (synchronously) or indirectly via 
				// a kafka messaging layer (asynchronously).
				// If we want to feed the LR events as fast as possible instead of the 
				// interposed delays as done by the LR data feeder, we can configure below as none.
				// Then, we must adjust the FileSource operator below to read from the data file very fast.
				//
				// Possible values: tcp, kafka, none
				dataReceiver: tcp;
				// 200x version
				startingExpressway: 160u;
				endingExpressway: 169u;
				
			config
				// Place the data ingestion operator on a particular machine where the LR input files are stored.
				// placement: partitionColocation("LR-DataFeeder");
				placement: host(lrPool[1]), partitionColocation("LR-DataFeeder17");
		}		
		// 200x version
		(stream<LinearRoadEventType> LREventViaTcp18;
		 stream<LinearRoadEventCsvType> LREventToKafkaTopic18) = DataFeeder() {
			param
				// Start sending data feeds after this one time delay. That will give
				// all the distributed operators in this application topology to get
				// connected properly on time before the data hits all of them.
				initDelay: (uint32)$INIT_DELAY_VALUE;
				dataFile: $LINEAR_ROAD_DATA_FILE_NAME;
				// Our LR data feeder can send the data either directly to the rest of the 
				// application topology via tcp (synchronously) or indirectly via 
				// a kafka messaging layer (asynchronously).
				// If we want to feed the LR events as fast as possible instead of the 
				// interposed delays as done by the LR data feeder, we can configure below as none.
				// Then, we must adjust the FileSource operator below to read from the data file very fast.
				//
				// Possible values: tcp, kafka, none
				dataReceiver: tcp;
				// 200x version
				startingExpressway: 170u;
				endingExpressway: 179u;
				
			config
				// Place the data ingestion operator on a particular machine where the LR input files are stored.
				// placement: partitionColocation("LR-DataFeeder");
				placement: host(lrPool[3]), partitionColocation("LR-DataFeeder18");
		}
		// 200x version
		(stream<LinearRoadEventType> LREventViaTcp19;
		 stream<LinearRoadEventCsvType> LREventToKafkaTopic19) = DataFeeder() {
			param
				// Start sending data feeds after this one time delay. That will give
				// all the distributed operators in this application topology to get
				// connected properly on time before the data hits all of them.
				initDelay: (uint32)$INIT_DELAY_VALUE;
				dataFile: $LINEAR_ROAD_DATA_FILE_NAME;
				// Our LR data feeder can send the data either directly to the rest of the 
				// application topology via tcp (synchronously) or indirectly via 
				// a kafka messaging layer (asynchronously).
				// If we want to feed the LR events as fast as possible instead of the 
				// interposed delays as done by the LR data feeder, we can configure below as none.
				// Then, we must adjust the FileSource operator below to read from the data file very fast.
				//
				// Possible values: tcp, kafka, none
				dataReceiver: tcp;
				// 200x version
				startingExpressway: 180u;
				endingExpressway: 189u;
				
			config
				// Place the data ingestion operator on a particular machine where the LR input files are stored.
				// placement: partitionColocation("LR-DataFeeder");
				placement: host(lrPool[4]), partitionColocation("LR-DataFeeder19");
		}
		// 200x version
		(stream<LinearRoadEventType> LREventViaTcp20;
		 stream<LinearRoadEventCsvType> LREventToKafkaTopic20) = DataFeeder() {
			param
				// Start sending data feeds after this one time delay. That will give
				// all the distributed operators in this application topology to get
				// connected properly on time before the data hits all of them.
				initDelay: (uint32)$INIT_DELAY_VALUE;
				dataFile: $LINEAR_ROAD_DATA_FILE_NAME;
				// Our LR data feeder can send the data either directly to the rest of the 
				// application topology via tcp (synchronously) or indirectly via 
				// a kafka messaging layer (asynchronously).
				// If we want to feed the LR events as fast as possible instead of the 
				// interposed delays as done by the LR data feeder, we can configure below as none.
				// Then, we must adjust the FileSource operator below to read from the data file very fast.
				//
				// Possible values: tcp, kafka, none
				dataReceiver: tcp;
				// 200x version
				startingExpressway: 190u;
				endingExpressway: 199u;
				
			config
				// Place the data ingestion operator on a particular machine where the LR input files are stored.
				// placement: partitionColocation("LR-DataFeeder");
				placement: host(lrPool[0]), partitionColocation("LR-DataFeeder20");
		}
		
		
		// 200x version --> A direct continuous read of car events below is good only for the
		// non 200x versions. This code block is simply present here dormant but not much useful.
		// It requires some cleanup to be included in the main flow for the 100x version.
		//
		// The original Linear Road data feeder logic (written by MIT, Brown and others) tries to
		// emit events according to the 3 hours long simulation period with plenty of interarrival
		// delays interposed in between those events. If we want to feed the data as fast as possible,
		// that original data feeder code written by the Linear Road development team is not going to
		// help us. When we want a must faster data feed, we can disable the original Linear Road
		// data feeder logic by configuring its "dataReceiver" parameter with node instead of tcp or kafka.
		// After doing that, we can activiate the folowing FileSource operator by reducing its init delay to
		// 45 seconds instead of 30 days (2,592,000 seconds).
		stream<LinearRoadEventCsvType> LREventViaFileSource = FileSource()
		{
			param
				// Start sending data feeds after this one time delay. That will give
				// all the distributed operators in this application topology to get
				// connected properly on time before the data hits all of them.
				//
				// Depending on whether to use the original Linear Road data feeder logic or
				// not, uncomment one of the following two initDelay lines.
				// If you want to activate this FileSource operator, use a shorter initDelay below and
				// you must configure the dataReceiver parameter of the DataFeeder operator above to
				// none instead of tcp or kafka.
				//
				initDelay: $INIT_DELAY_FOR_THIRTY_DAYS;
				// initDelay: $INIT_DELAY_VALUE;
				file: $LINEAR_ROAD_DATA_FILE_NAME;
				format: line;

			config
				// Fuse it with the data feeder operator.			
				placement: partitionColocation("LR-DataFeeder1");
		}		

		// 200x version --> Kafka publishing of car events below is good only for the
		// non 200x versions. This code block is simply present here dormant but not much useful.
		// It requires some cleanup to be included in the main flow for the 100x version.
		//
		// If the data feeder operator was configured with kafka as the data receiver, then
		// the CSV formatted LR events will arrive here at this Kafka Producer operator.
		// This will keep publishing those events on a kafka topic for an asynchronous 
		// pickup later by a different KakfaConsumer operator running on an entirely
		// different machine than the one where the (DataFeeder + KafkaProducer) pair is running. 
		() as LRKafkaPublish = KafkaProducer(LREventToKafkaTopic1, LREventToKafkaTopic2,
			LREventToKafkaTopic3, LREventToKafkaTopic4, LREventToKafkaTopic5,
			LREventToKafkaTopic6, LREventToKafkaTopic7,
			LREventToKafkaTopic8, LREventToKafkaTopic9, LREventToKafkaTopic10,
			LREventToKafkaTopic11, LREventToKafkaTopic12, LREventToKafkaTopic13,
			LREventToKafkaTopic14, LREventToKafkaTopic15, LREventToKafkaTopic16, 
			LREventToKafkaTopic17, LREventToKafkaTopic18, LREventToKafkaTopic19, 
			LREventToKafkaTopic20 ) {
			param
				propertiesFile : "etc/lr-producer.properties" ;
				// Incoming tuples will only have a single rstring message attribute.
				// Hence, we must specify the topic name where we want to publish the tuples.
				topic: $LR_KAFKA_TOPIC_NAME;
		
			config
				// Fuse it with the data feeder operator.			
				placement: partitionColocation("LR-DataFeeder1");
		}		 
		
// ****************** Data Feeder logic ends here ******************

// ****************** Event splitter logic begins here ******************
		// A very simple Beacon that signals the following Custom operator every minute.
		// It is done primarily to print the very final event received at the end of the Linear Road processing.
		stream<int8 signal> TimerSignal = Beacon() {
			param
				period: 60.00;
				
			config
				// Run it on a different machine away from the DataFeeder.
				placement: host(lrPool[0]), partitionColocation("LR-DataReceiver1");
		}

		// 100x version --> Kafka consumption of car events below is good only for the
		// non 100x versions. This code block is simply present here dormant but not much useful.
		// It requires some cleanup to be included in the main flow for the 100x version.
		//
		// Our LR data feeder can be configured to send data either synchronously (via TCP) or
		// asynchronously (via Kafka queues). If the data arrives via Kafka, let us 
		// receive it a in this operator.
		//
		// IMPORTANT
		// ---------
		// Kafka only provides a total order over messages within a partition, not between
		// different partitions in a topic. In this application, our Kafka topic was created
		// only with a single partition using the "kafka-topics.sh" script.
		// For the LR scenario, tuples must arrive here in the exact time order in which the
		// data feeder is sending them. Since we require that total order over messages, this can be
		// achieved with a topic that has only one partition, though this will mean only one consumer process. 
		//
		// What all this means is we can't apply UDP annotations to this operator in the 
		// context of this particular application.
		stream<LinearRoadEventCsvType> LREventFromKafkaTopic = KafkaConsumer()
		{
			param
				propertiesFile : "etc/lr-consumer.properties";
				topic : $LR_KAFKA_TOPIC_NAME;

			config
				// Fuse it with the LR-DataReceiver partition.
				placement: partitionColocation("LR-DataReceiver1");
		}		

		// 100x version --> Conversion of CSV formatted car events to tuples below is good only for the
		// non 100x versions. This code block is simply present here dormant but not much useful.
		// It requires some cleanup to be included in the main flow for the 100x version.
		//
		stream<LinearRoadEventType> LREventViaKafka = Custom(LREventFromKafkaTopic, LREventViaFileSource as LRE) {
			logic
				state: {
					mutable LinearRoadEventType _oTuple = {};
					mutable list<rstring> _tokens = [];
				}
				
				// This stream of data will arrive here either from the Kafka consumer or from the file source. 
				onTuple LRE: {
					// Kafka can't directly deal with Streams tuples. Hence, the data feeder is
					// publishing the LR events as CSV formatted strings into the Kafka topic.
					// Let us now tranform that CSV string into an LR event tuple with all its
					// attributes populated correctly.
					_tokens = csvTokenize(LRE.message);
					// Populate the output tuple attributes now.
   					_oTuple.eventType = (int32)_tokens[0];
   					_oTuple.eventTxTimestamp = (int32)_tokens[1];
   					_oTuple.vehicleId = (int32)_tokens[2];
   					_oTuple.vehicleSpeed = (int32)_tokens[3];
   					_oTuple.expressWayNumber = (int32)_tokens[4];
   					_oTuple.laneNumber = (int32)_tokens[5];
   					_oTuple.directionIndicator = (int32)_tokens[6];
   					_oTuple.segmentId = (int32)_tokens[7];
   					_oTuple.vehiclePosition = (int32)_tokens[8];
   					_oTuple.queryId = (int32)_tokens[9];
   					_oTuple.startingSegment = (int32)_tokens[10];
   					_oTuple.endingSegment = (int32)_tokens[11];
   					_oTuple.dayOfWeek = (int32)_tokens[12];
   					_oTuple.minuteOfCurrentDay = (int32)_tokens[13];
   					_oTuple.dayInThePast = (int32)_tokens[14];
   					// Please note that we will not assign a value for the
   					// very last tuple attribute eventRxTimestamp since that never gets
   					// sent by the data feeder. We will take care of that particular
   					// attribute in the next downstream operator.
   					submit(_oTuple, LREventViaKafka);
				}

			config
				// Fuse it with the LR-DataReceiver partition.
				placement: partitionColocation("LR-DataReceiver1");
		}
		
// ==================================================================
		// Bank 1
		// Linear Road scenario has 4 event types: 
		// 0) Position reports (real time a.k.a continuous query)
		// 2) Account balance (historical query)
		// 3) Daily expenditure report (historical query)
		// 4) Travel time estimation (historical query)
		//
		// In this application, we will only handle the first three event types and skip the fourth one.
		// Split the incoming data according to the event type in order for them to reach the 
		// appropriate downstream operators capable of processing a specific event.
		//
		// Incoming LR events will arrive here either directly from the data feeder (via TCP) or
		// from an asynchronous messaging system (via kafka).
		// 100x version --> Receive and route data for expressways 0 to 9
		(stream<LinearRoadEventType> PositionReport_1; stream<LinearRoadEventType> DailyExpenditure1) =
			Custom(LREventViaTcp1, LREventViaKafka as LRE; TimerSignal as TS) {
			logic
				state: {
					mutable uint64 _eventCnt = 0ul;
					mutable uint64 _lastKnownEventCnt = 0ul;
					mutable boolean _linearRoadProcessingEnded = false;
					mutable VehicleExpresswayInfoType _vehicleExpresswayInfoTuple = {};
					mutable map<int32, VehicleExpresswayInfoType> _vehicleExpresswayInfoCache = {};
					mutable LinearRoadEventType _mostRecentlyReceivedEvent = {};
					mutable int32 _emptyEventsReceivedErrorCnt = 0;
					mutable int32 _unconfiguredExpresswayType0AndType3EventsReceived = 0;
					mutable int32 _unconfiguredExpresswayType2EventsReceived = 0;
				}
				
				onTuple LRE: {
					// The LR Data feeder seems to send a completely empty event record with all the
					// attributes set to a value of 0. This happens when the data feeder reaches the
					// very end of the data file. We will catch that event with an invalid vehicleId
					// of 0 and discard it.
					if (LRE.vehicleId <= 0) {
						appTrc(Trace.debug, "_X_EEEEEEEEEEEEEEEEEEEEE (Inside the event splitter operator) " +
							"Received a tuple with an empty vehicle id right after the event " + 
							(rstring)_eventCnt + " and discarded it." +
							" Incoming Event=" + (rstring)LRE);		
						_emptyEventsReceivedErrorCnt++;				
						return;
					}

					// For the 15 xways and 25 xways, we will be using the 50 xways data set since 
					// we didn't generate separate data set files for 15x and 25x. In that case, we will
					// have to discard the LR events that are targetted for an unconfigured expressway.
					// That is what is being done in the next two if blocks.
					//					
					// If the incoming LR event is not for one of the configured expressways, then we can ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) && 
						(LRE.eventType == $POSTION_REPORT_EVENT || LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) && 
						(LRE.expressWayNumber >= <%=$totalNumberOfExpressways%>)) {
						// This LR event is for an expressway that is higher than
						// what is configured in this composite via a PERL variable.
						_unconfiguredExpresswayType0AndType3EventsReceived++;
						return;
					}
					
					// If the incoming Account Balance LR event has a vehicle id that has not been seen in
					// any of the configured expressways, then we will ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) &&
						(LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) &&
						((LRE.vehicleId in _vehicleExpresswayInfoCache) == false)) {
						_unconfiguredExpresswayType2EventsReceived++;
						return;	
					}
					
					// As soon as we receive an LR event, we must record the event reception time.
					// This will be used later to calculate the time we are going to take in processing this event.
					LRE.eventRxTimestamp = getSeconds(getTimestamp());
					_eventCnt++;
					// Let us keep a copy of the most recently received event in a state variable.
					// This will be used to print the very last tuple that came from the data feeder when
					// the entire Linear Road processing is completed.
					assignFrom(_mostRecentlyReceivedEvent, LRE);
					
					// Always print the very first event.
					// After that, print only once for every 500K events.
					if ((_eventCnt == 1ul) || ((_eventCnt % 500000ul) == 0ul))  {
						if (_eventCnt == 1ul) {
							appTrc(Trace.error, "******* START OF LINEAR ROAD PROCESSING (main application entry point) *******");
						}
					
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)LRE);
					}

					// Now, route it to the appropriate event processor based on the event type.
					if (LRE.eventType == $POSTION_REPORT_EVENT) {
						// Store in which expressway a given vehicle is traveling now.
						// This is needed for routing the type 2 account balance queries to the 
						// correct type 0 event processor's parallel channel. See more comments in the
						// following "else if" block.						
						_vehicleExpresswayInfoTuple.expressWayNumber = LRE.expressWayNumber;
						_vehicleExpresswayInfoTuple.directionIndicator = LRE.directionIndicator;
						insertM(_vehicleExpresswayInfoCache, LRE.vehicleId, _vehicleExpresswayInfoTuple);
						submit(LRE, PositionReport_1);
					} else if (LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) {
						// Please note that any account balance query will have to be routed via
						// the position report event processor in order to maintain the tuple arrival order.
						// That will allow the position report event processor to be ready with the
						// balance for a given vehicle by the time the account balance (type 2) query
						// hits this Streams application. So, send a type 2 event to the type 0 event
						// processor which in turn will forward that type 2 event to the correct
						// account balance event processor below.
						// If we don't route a type 2 event via the type 0 event processor, then it will
						// cause cache misses in the DPS store by getting ahead of a more recent type 0
						// event that is still waiting inside the input queue of the very busy position
						// report event processor. Hence, let us make this type 2 event sojourn inside
						// the PositionReportEventProcessor for a little while before it is forwarded from
						// there to its own Type 2 event processor.
						//
						// This is going to be tricky since account balance queries are done only by
						// sending us the vehicle id. So, we have to simply know in which expressway and
						// direction that vehicle was seen last and route this type 2 event to a specific
						// instance of the position report event processor PE. That is why, we are maintaining
						// a separate map to find out a given vehicle's last known expressway and direction.
						//
						if (LRE.vehicleId in _vehicleExpresswayInfoCache) {
							// Assign the last known expressway and direction indicator for this vehicle.
							// With these values, it will land in the correct type 0 event processor where this
							// vehicle is already getting processed. We want this type 2 event to line up
							// behind those type 0 events belonging to a given vehicle.
							LRE.expressWayNumber =  _vehicleExpresswayInfoCache[LRE.vehicleId].expressWayNumber;
							LRE.directionIndicator = _vehicleExpresswayInfoCache[LRE.vehicleId].directionIndicator;
						} else {
							// This vehicle has not yet sent its very first position report to us.
							// That means, a type 2 event is coming much before the very first type 0 event for
							// that vehicle is sent to our application. (This can be double-checked in the data set.)
							// In such cases, we will simply send it to the very first position report event processor that
							// is handling expressway 0 and direction indicatior 0 (eastbound) to get forwarded from
							// there to the type 2 event processor.
							LRE.expressWayNumber =  0;
							LRE.directionIndicator = 0;
						}

						// It will now get shuttled to a particular channel of the PositionReportEventProcessor's parallel
						// region and then get forwarded from there to the type 2 event processor thereby putting it
						// in the right spot to obtain and respond with the most recently updated account balance for
						// a given vehicle. 
						submit(LRE, PositionReport_1);
					} else if (LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) {
						// LR specification says, we should respond to a type 3 event only for those days that were in the past.
						// If this type 3 event asks about the daily expenditure for today i.e. dayInThePast = 0,
						// we can simply ignore it by not sending any response back.
						if (LRE.dayInThePast > 0) {
							submit(LRE, DailyExpenditure1);
						} else {
							// Ignore a type 3 event that is asking about the daily expenditure for the current day.
							appTrc(Trace.debug, "_X_DDDDDDDDDDDDDD (Inside the event splitter operator) " +
								"Ignoring the type 3 event asking for daily expenditure with dayInThePast set to 0." +
								" Incoming Type 3 Event=" + (rstring)LRE);
						}
					}
				}
				
				onTuple TS: {
					// Let us see if the entire processing had ended so that we can print a closing line in the log file.
					if ((_eventCnt <= 0ul) || (_linearRoadProcessingEnded == true)) {
						// If the application run has not even started, nothing to do here and simply return back.
						// Do the same thing when the linear road processing had already ended.
						return;
					}
					
					if (_lastKnownEventCnt < _eventCnt) {
						// Linear road processing is actively in progress. Let us keep it going.
						_lastKnownEventCnt = _eventCnt;
					} else if (_lastKnownEventCnt == _eventCnt) {
						// Event count has not changed since we last visited here.
						// That means, Linear Road processing must have ended.
						// Let us print the final message in the PE log.
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)_mostRecentlyReceivedEvent);
						appTrc(Trace.error, "Empty event tuple error count = " + (rstring)_emptyEventsReceivedErrorCnt);
						appTrc(Trace.error, "Type 0 and 3 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType0AndType3EventsReceived);
						appTrc(Trace.error, "Type 2 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType2EventsReceived);
						appTrc(Trace.error, "******* END OF LINEAR ROAD PROCESSING (main application entry point) *******");
						_linearRoadProcessingEnded = true;
					} 
				}
				
			config
				threadedPort: queue(LRE, Sys.Wait);
				// Fuse it with the LR-DataReceiver partition.
				placement: partitionColocation("LR-DataReceiver1");
		}
		
		// We will split the type 0 position report events to go to the individual instances of
		// the type 0 event processor operator based on a unique combination of
		// "expressWayNumber + directionIndicator".
		<% my $cnt = 0; %>
		(
		 <% for ($cnt = 1; $cnt <= 20; $cnt++) { %>
		 stream<LinearRoadEventType> PositionReport<%=$cnt%><% if ($cnt < 20) { %>; <% }} %>
		) = Split(PositionReport_1 as PR) {				
			param
				file: getApplicationDir() +  "/etc/routing-map-for-type0-events-splitter1.txt";
				key: (rstring)PR.expressWayNumber + "_" + (rstring)PR.directionIndicator;

			config
				// Fuse it with the LR-DataReceiver partition.
				placement: partitionColocation("LR-DataReceiver1");
		} 

// ==================================================================
		// Bank 2
		// Linear Road scenario has 4 event types: 
		// 0) Position reports (real time a.k.a continuous query)
		// 2) Account balance (historical query)
		// 3) Daily expenditure report (historical query)
		// 4) Travel time estimation (historical query)
		//
		// In this application, we will only handle the first three event types and skip the fourth one.
		// Split the incoming data according to the event type in order for them to reach the 
		// appropriate downstream operators capable of processing a specific event.
		//
		// Incoming LR events will arrive here either directly from the data feeder (via TCP) or
		// from an asynchronous messaging system (via kafka).
		// 100x version --> Receive and route data for expressways 10 to 19
		(stream<LinearRoadEventType> PositionReport_2; stream<LinearRoadEventType> DailyExpenditure2) =
			Custom(LREventViaTcp2 as LRE; TimerSignal as TS) {
			logic
				state: {
					mutable uint64 _eventCnt = 0ul;
					mutable uint64 _lastKnownEventCnt = 0ul;
					mutable boolean _linearRoadProcessingEnded = false;
					mutable VehicleExpresswayInfoType _vehicleExpresswayInfoTuple = {};
					mutable map<int32, VehicleExpresswayInfoType> _vehicleExpresswayInfoCache = {};
					mutable LinearRoadEventType _mostRecentlyReceivedEvent = {};
					mutable int32 _emptyEventsReceivedErrorCnt = 0;
					mutable int32 _unconfiguredExpresswayType0AndType3EventsReceived = 0;
					mutable int32 _unconfiguredExpresswayType2EventsReceived = 0;
				}
				
				onTuple LRE: {
					// The LR Data feeder seems to send a completely empty event record with all the
					// attributes set to a value of 0. This happens when the data feeder reaches the
					// very end of the data file. We will catch that event with an invalid vehicleId
					// of 0 and discard it.
					if (LRE.vehicleId <= 0) {
						appTrc(Trace.debug, "_X_EEEEEEEEEEEEEEEEEEEEE (Inside the event splitter operator) " +
							"Received a tuple with an empty vehicle id right after the event " + 
							(rstring)_eventCnt + " and discarded it." +
							" Incoming Event=" + (rstring)LRE);		
						_emptyEventsReceivedErrorCnt++;				
						return;
					}

					// For the 15 xways and 25 xways, we will be using the 50 xways data set since 
					// we didn't generate separate data set files for 15x and 25x. In that case, we will
					// have to discard the LR events that are targetted for an unconfigured expressway.
					// That is what is being done in the next two if blocks.
					//					
					// If the incoming LR event is not for one of the configured expressways, then we can ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) && 
						(LRE.eventType == $POSTION_REPORT_EVENT || LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) && 
						(LRE.expressWayNumber >= <%=$totalNumberOfExpressways%>)) {
						// This LR event is for an expressway that is higher than
						// what is configured in this composite via a PERL variable.
						_unconfiguredExpresswayType0AndType3EventsReceived++;
						return;
					}
					
					// If the incoming Account Balance LR event has a vehicle id that has not been seen in
					// any of the configured expressways, then we will ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) &&
						(LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) &&
						((LRE.vehicleId in _vehicleExpresswayInfoCache) == false)) {
						_unconfiguredExpresswayType2EventsReceived++;
						return;	
					}
					
					// As soon as we receive an LR event, we must record the event reception time.
					// This will be used later to calculate the time we are going to take in processing this event.
					LRE.eventRxTimestamp = getSeconds(getTimestamp());
					_eventCnt++;
					// Let us keep a copy of the most recently received event in a state variable.
					// This will be used to print the very last tuple that came from the data feeder when
					// the entire Linear Road processing is completed.
					assignFrom(_mostRecentlyReceivedEvent, LRE);
					
					// Always print the very first event.
					// After that, print only once for every 500K events.
					if ((_eventCnt == 1ul) || ((_eventCnt % 500000ul) == 0ul))  {
						if (_eventCnt == 1ul) {
							appTrc(Trace.error, "******* START OF LINEAR ROAD PROCESSING (main application entry point) *******");
						}
					
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)LRE);
					}

					// Now, route it to the appropriate event processor based on the event type.
					if (LRE.eventType == $POSTION_REPORT_EVENT) {
						// Store in which expressway a given vehicle is traveling now.
						// This is needed for routing the type 2 account balance queries to the 
						// correct type 0 event processor's parallel channel. See more comments in the
						// following "else if" block.						
						_vehicleExpresswayInfoTuple.expressWayNumber = LRE.expressWayNumber;
						_vehicleExpresswayInfoTuple.directionIndicator = LRE.directionIndicator;
						insertM(_vehicleExpresswayInfoCache, LRE.vehicleId, _vehicleExpresswayInfoTuple);
						submit(LRE, PositionReport_2);
					} else if (LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) {
						// Please note that any account balance query will have to be routed via
						// the position report event processor in order to maintain the tuple arrival order.
						// That will allow the position report event processor to be ready with the
						// balance for a given vehicle by the time the account balance (type 2) query
						// hits this Streams application. So, send a type 2 event to the type 0 event
						// processor which in turn will forward that type 2 event to the correct
						// account balance event processor below.
						// If we don't route a type 2 event via the type 0 event processor, then it will
						// cause cache misses in the DPS store by getting ahead of a more recent type 0
						// event that is still waiting inside the input queue of the very busy position
						// report event processor. Hence, let us make this type 2 event sojourn inside
						// the PositionReportEventProcessor for a little while before it is forwarded from
						// there to its own Type 2 event processor.
						//
						// This is going to be tricky since account balance queries are done only by
						// sending us the vehicle id. So, we have to simply know in which expressway and
						// direction that vehicle was seen last and route this type 2 event to a specific
						// instance of the position report event processor PE. That is why, we are maintaining
						// a separate map to find out a given vehicle's last known expressway and direction.
						//
						if (LRE.vehicleId in _vehicleExpresswayInfoCache) {
							// Assign the last known expressway and direction indicator for this vehicle.
							// With these values, it will land in the correct type 0 event processor where this
							// vehicle is already getting processed. We want this type 2 event to line up
							// behind those type 0 events belonging to a given vehicle.
							LRE.expressWayNumber =  _vehicleExpresswayInfoCache[LRE.vehicleId].expressWayNumber;
							LRE.directionIndicator = _vehicleExpresswayInfoCache[LRE.vehicleId].directionIndicator;
						} else {
							// This vehicle has not yet sent its very first position report to us.
							// That means, a type 2 event is coming much before the very first type 0 event for
							// that vehicle is sent to our application. (This can be double-checked in the data set.)
							// In such cases, we will simply send it to the very first position report event processor that
							// is handling expressway 0 and direction indicatior 0 (eastbound) to get forwarded from
							// there to the type 2 event processor.
							LRE.expressWayNumber =  10;
							LRE.directionIndicator = 0;
						}

						// It will now get shuttled to a particular channel of the PositionReportEventProcessor's parallel
						// region and then get forwarded from there to the type 2 event processor thereby putting it
						// in the right spot to obtain and respond with the most recently updated account balance for
						// a given vehicle. 
						submit(LRE, PositionReport_2);
					} else if (LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) {
						// LR specification says, we should respond to a type 3 event only for those days that were in the past.
						// If this type 3 event asks about the daily expenditure for today i.e. dayInThePast = 0,
						// we can simply ignore it by not sending any response back.
						if (LRE.dayInThePast > 0) {
							submit(LRE, DailyExpenditure2);
						} else {
							// Ignore a type 3 event that is asking about the daily expenditure for the current day.
							appTrc(Trace.debug, "_X_DDDDDDDDDDDDDD (Inside the event splitter operator) " +
								"Ignoring the type 3 event asking for daily expenditure with dayInThePast set to 0." +
								" Incoming Type 3 Event=" + (rstring)LRE);
						}
					}
				}
				
				onTuple TS: {
					// Let us see if the entire processing had ended so that we can print a closing line in the log file.
					if ((_eventCnt <= 0ul) || (_linearRoadProcessingEnded == true)) {
						// If the application run has not even started, nothing to do here and simply return back.
						// Do the same thing when the linear road processing had already ended.
						return;
					}
					
					if (_lastKnownEventCnt < _eventCnt) {
						// Linear road processing is actively in progress. Let us keep it going.
						_lastKnownEventCnt = _eventCnt;
					} else if (_lastKnownEventCnt == _eventCnt) {
						// Event count has not changed since we last visited here.
						// That means, Linear Road processing must have ended.
						// Let us print the final message in the PE log.
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)_mostRecentlyReceivedEvent);
						appTrc(Trace.error, "Empty event tuple error count = " + (rstring)_emptyEventsReceivedErrorCnt);
						appTrc(Trace.error, "Type 0 and 3 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType0AndType3EventsReceived);
						appTrc(Trace.error, "Type 2 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType2EventsReceived);
						appTrc(Trace.error, "******* END OF LINEAR ROAD PROCESSING (main application entry point) *******");
						_linearRoadProcessingEnded = true;
					} 
				}
				
			config
				threadedPort: queue(LRE, Sys.Wait);
				// Fuse it with the LR-DataReceiver partition.
				placement: host(lrPool[1]), partitionColocation("LR-DataReceiver2");
		}
		
		// We will split the type 0 position report events to go to the individual instances of
		// the type 0 event processor operator based on a unique combination of
		// "expressWayNumber + directionIndicator".
		<% my $cnt = 0; %>
		(
		 <% for ($cnt = 21; $cnt <= 40; $cnt++) { %>
		 stream<LinearRoadEventType> PositionReport<%=$cnt%><% if ($cnt < 40) { %>; <% }} %>
		) = Split(PositionReport_2 as PR) {				
			param
				file: getApplicationDir() +  "/etc/routing-map-for-type0-events-splitter2.txt";
				key: (rstring)PR.expressWayNumber + "_" + (rstring)PR.directionIndicator;

			config
				// Fuse it with the LR-DataReceiver partition.
				placement: partitionColocation("LR-DataReceiver2");
		} 
// ==================================================================
		// Bank 3
		// Linear Road scenario has 4 event types: 
		// 0) Position reports (real time a.k.a continuous query)
		// 2) Account balance (historical query)
		// 3) Daily expenditure report (historical query)
		// 4) Travel time estimation (historical query)
		//
		// In this application, we will only handle the first three event types and skip the fourth one.
		// Split the incoming data according to the event type in order for them to reach the 
		// appropriate downstream operators capable of processing a specific event.
		//
		// Incoming LR events will arrive here either directly from the data feeder (via TCP) or
		// from an asynchronous messaging system (via kafka).
		// 100x version --> Receive and route data for expressways 20 to 29
		(stream<LinearRoadEventType> PositionReport_3; stream<LinearRoadEventType> DailyExpenditure3) =
			Custom(LREventViaTcp3 as LRE; TimerSignal as TS) {
			logic
				state: {
					mutable uint64 _eventCnt = 0ul;
					mutable uint64 _lastKnownEventCnt = 0ul;
					mutable boolean _linearRoadProcessingEnded = false;
					mutable VehicleExpresswayInfoType _vehicleExpresswayInfoTuple = {};
					mutable map<int32, VehicleExpresswayInfoType> _vehicleExpresswayInfoCache = {};
					mutable LinearRoadEventType _mostRecentlyReceivedEvent = {};
					mutable int32 _emptyEventsReceivedErrorCnt = 0;
					mutable int32 _unconfiguredExpresswayType0AndType3EventsReceived = 0;
					mutable int32 _unconfiguredExpresswayType2EventsReceived = 0;
				}
				
				onTuple LRE: {
					// The LR Data feeder seems to send a completely empty event record with all the
					// attributes set to a value of 0. This happens when the data feeder reaches the
					// very end of the data file. We will catch that event with an invalid vehicleId
					// of 0 and discard it.
					if (LRE.vehicleId <= 0) {
						appTrc(Trace.debug, "_X_EEEEEEEEEEEEEEEEEEEEE (Inside the event splitter operator) " +
							"Received a tuple with an empty vehicle id right after the event " + 
							(rstring)_eventCnt + " and discarded it." +
							" Incoming Event=" + (rstring)LRE);		
						_emptyEventsReceivedErrorCnt++;				
						return;
					}

					// For the 15 xways and 25 xways, we will be using the 50 xways data set since 
					// we didn't generate separate data set files for 15x and 25x. In that case, we will
					// have to discard the LR events that are targetted for an unconfigured expressway.
					// That is what is being done in the next two if blocks.
					//					
					// If the incoming LR event is not for one of the configured expressways, then we can ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) && 
						(LRE.eventType == $POSTION_REPORT_EVENT || LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) && 
						(LRE.expressWayNumber >= <%=$totalNumberOfExpressways%>)) {
						// This LR event is for an expressway that is higher than
						// what is configured in this composite via a PERL variable.
						_unconfiguredExpresswayType0AndType3EventsReceived++;
						return;
					}
					
					// If the incoming Account Balance LR event has a vehicle id that has not been seen in
					// any of the configured expressways, then we will ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) &&
						(LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) &&
						((LRE.vehicleId in _vehicleExpresswayInfoCache) == false)) {
						_unconfiguredExpresswayType2EventsReceived++;
						return;	
					}
					
					// As soon as we receive an LR event, we must record the event reception time.
					// This will be used later to calculate the time we are going to take in processing this event.
					LRE.eventRxTimestamp = getSeconds(getTimestamp());
					_eventCnt++;
					// Let us keep a copy of the most recently received event in a state variable.
					// This will be used to print the very last tuple that came from the data feeder when
					// the entire Linear Road processing is completed.
					assignFrom(_mostRecentlyReceivedEvent, LRE);
					
					// Always print the very first event.
					// After that, print only once for every 500K events.
					if ((_eventCnt == 1ul) || ((_eventCnt % 500000ul) == 0ul))  {
						if (_eventCnt == 1ul) {
							appTrc(Trace.error, "******* START OF LINEAR ROAD PROCESSING (main application entry point) *******");
						}
					
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)LRE);
					}

					// Now, route it to the appropriate event processor based on the event type.
					if (LRE.eventType == $POSTION_REPORT_EVENT) {
						// Store in which expressway a given vehicle is traveling now.
						// This is needed for routing the type 2 account balance queries to the 
						// correct type 0 event processor's parallel channel. See more comments in the
						// following "else if" block.						
						_vehicleExpresswayInfoTuple.expressWayNumber = LRE.expressWayNumber;
						_vehicleExpresswayInfoTuple.directionIndicator = LRE.directionIndicator;
						insertM(_vehicleExpresswayInfoCache, LRE.vehicleId, _vehicleExpresswayInfoTuple);
						submit(LRE, PositionReport_3);
					} else if (LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) {
						// Please note that any account balance query will have to be routed via
						// the position report event processor in order to maintain the tuple arrival order.
						// That will allow the position report event processor to be ready with the
						// balance for a given vehicle by the time the account balance (type 2) query
						// hits this Streams application. So, send a type 2 event to the type 0 event
						// processor which in turn will forward that type 2 event to the correct
						// account balance event processor below.
						// If we don't route a type 2 event via the type 0 event processor, then it will
						// cause cache misses in the DPS store by getting ahead of a more recent type 0
						// event that is still waiting inside the input queue of the very busy position
						// report event processor. Hence, let us make this type 2 event sojourn inside
						// the PositionReportEventProcessor for a little while before it is forwarded from
						// there to its own Type 2 event processor.
						//
						// This is going to be tricky since account balance queries are done only by
						// sending us the vehicle id. So, we have to simply know in which expressway and
						// direction that vehicle was seen last and route this type 2 event to a specific
						// instance of the position report event processor PE. That is why, we are maintaining
						// a separate map to find out a given vehicle's last known expressway and direction.
						//
						if (LRE.vehicleId in _vehicleExpresswayInfoCache) {
							// Assign the last known expressway and direction indicator for this vehicle.
							// With these values, it will land in the correct type 0 event processor where this
							// vehicle is already getting processed. We want this type 2 event to line up
							// behind those type 0 events belonging to a given vehicle.
							LRE.expressWayNumber =  _vehicleExpresswayInfoCache[LRE.vehicleId].expressWayNumber;
							LRE.directionIndicator = _vehicleExpresswayInfoCache[LRE.vehicleId].directionIndicator;
						} else {
							// This vehicle has not yet sent its very first position report to us.
							// That means, a type 2 event is coming much before the very first type 0 event for
							// that vehicle is sent to our application. (This can be double-checked in the data set.)
							// In such cases, we will simply send it to the very first position report event processor that
							// is handling expressway 0 and direction indicatior 0 (eastbound) to get forwarded from
							// there to the type 2 event processor.
							LRE.expressWayNumber =  20;
							LRE.directionIndicator = 0;
						}

						// It will now get shuttled to a particular channel of the PositionReportEventProcessor's parallel
						// region and then get forwarded from there to the type 2 event processor thereby putting it
						// in the right spot to obtain and respond with the most recently updated account balance for
						// a given vehicle. 
						submit(LRE, PositionReport_3);
					} else if (LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) {
						// LR specification says, we should respond to a type 3 event only for those days that were in the past.
						// If this type 3 event asks about the daily expenditure for today i.e. dayInThePast = 0,
						// we can simply ignore it by not sending any response back.
						if (LRE.dayInThePast > 0) {
							submit(LRE, DailyExpenditure3);
						} else {
							// Ignore a type 3 event that is asking about the daily expenditure for the current day.
							appTrc(Trace.debug, "_X_DDDDDDDDDDDDDD (Inside the event splitter operator) " +
								"Ignoring the type 3 event asking for daily expenditure with dayInThePast set to 0." +
								" Incoming Type 3 Event=" + (rstring)LRE);
						}
					}
				}
				
				onTuple TS: {
					// Let us see if the entire processing had ended so that we can print a closing line in the log file.
					if ((_eventCnt <= 0ul) || (_linearRoadProcessingEnded == true)) {
						// If the application run has not even started, nothing to do here and simply return back.
						// Do the same thing when the linear road processing had already ended.
						return;
					}
					
					if (_lastKnownEventCnt < _eventCnt) {
						// Linear road processing is actively in progress. Let us keep it going.
						_lastKnownEventCnt = _eventCnt;
					} else if (_lastKnownEventCnt == _eventCnt) {
						// Event count has not changed since we last visited here.
						// That means, Linear Road processing must have ended.
						// Let us print the final message in the PE log.
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)_mostRecentlyReceivedEvent);
						appTrc(Trace.error, "Empty event tuple error count = " + (rstring)_emptyEventsReceivedErrorCnt);
						appTrc(Trace.error, "Type 0 and 3 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType0AndType3EventsReceived);
						appTrc(Trace.error, "Type 2 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType2EventsReceived);
						appTrc(Trace.error, "******* END OF LINEAR ROAD PROCESSING (main application entry point) *******");
						_linearRoadProcessingEnded = true;
					} 
				}
				
			config
				threadedPort: queue(LRE, Sys.Wait);
				// Fuse it with the LR-DataReceiver partition.
				placement: host(lrPool[1]), partitionColocation("LR-DataReceiver3");
		}
		
		// We will split the type 0 position report events to go to the individual instances of
		// the type 0 event processor operator based on a unique combination of
		// "expressWayNumber + directionIndicator".
		<% my $cnt = 0; %>
		(
		 <% for ($cnt = 41; $cnt <= 60; $cnt++) { %>
		 stream<LinearRoadEventType> PositionReport<%=$cnt%><% if ($cnt < 60) { %>; <% }} %>
		) = Split(PositionReport_3 as PR) {				
			param
				file: getApplicationDir() +  "/etc/routing-map-for-type0-events-splitter3.txt";
				key: (rstring)PR.expressWayNumber + "_" + (rstring)PR.directionIndicator;

			config
				// Fuse it with the LR-DataReceiver partition.
				placement: partitionColocation("LR-DataReceiver3");
		} 
// ==================================================================
		// Bank 4
		// Linear Road scenario has 4 event types: 
		// 0) Position reports (real time a.k.a continuous query)
		// 2) Account balance (historical query)
		// 3) Daily expenditure report (historical query)
		// 4) Travel time estimation (historical query)
		//
		// In this application, we will only handle the first three event types and skip the fourth one.
		// Split the incoming data according to the event type in order for them to reach the 
		// appropriate downstream operators capable of processing a specific event.
		//
		// Incoming LR events will arrive here either directly from the data feeder (via TCP) or
		// from an asynchronous messaging system (via kafka).
		// 100x version --> Receive and route data for expressways 30 to 39
		(stream<LinearRoadEventType> PositionReport_4; stream<LinearRoadEventType> DailyExpenditure4) =
			Custom(LREventViaTcp4 as LRE; TimerSignal as TS) {
			logic
				state: {
					mutable uint64 _eventCnt = 0ul;
					mutable uint64 _lastKnownEventCnt = 0ul;
					mutable boolean _linearRoadProcessingEnded = false;
					mutable VehicleExpresswayInfoType _vehicleExpresswayInfoTuple = {};
					mutable map<int32, VehicleExpresswayInfoType> _vehicleExpresswayInfoCache = {};
					mutable LinearRoadEventType _mostRecentlyReceivedEvent = {};
					mutable int32 _emptyEventsReceivedErrorCnt = 0;
					mutable int32 _unconfiguredExpresswayType0AndType3EventsReceived = 0;
					mutable int32 _unconfiguredExpresswayType2EventsReceived = 0;
				}
				
				onTuple LRE: {
					// The LR Data feeder seems to send a completely empty event record with all the
					// attributes set to a value of 0. This happens when the data feeder reaches the
					// very end of the data file. We will catch that event with an invalid vehicleId
					// of 0 and discard it.
					if (LRE.vehicleId <= 0) {
						appTrc(Trace.debug, "_X_EEEEEEEEEEEEEEEEEEEEE (Inside the event splitter operator) " +
							"Received a tuple with an empty vehicle id right after the event " + 
							(rstring)_eventCnt + " and discarded it." +
							" Incoming Event=" + (rstring)LRE);		
						_emptyEventsReceivedErrorCnt++;				
						return;
					}

					// For the 15 xways and 25 xways, we will be using the 50 xways data set since 
					// we didn't generate separate data set files for 15x and 25x. In that case, we will
					// have to discard the LR events that are targetted for an unconfigured expressway.
					// That is what is being done in the next two if blocks.
					//					
					// If the incoming LR event is not for one of the configured expressways, then we can ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) && 
						(LRE.eventType == $POSTION_REPORT_EVENT || LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) && 
						(LRE.expressWayNumber >= <%=$totalNumberOfExpressways%>)) {
						// This LR event is for an expressway that is higher than
						// what is configured in this composite via a PERL variable.
						_unconfiguredExpresswayType0AndType3EventsReceived++;
						return;
					}
					
					// If the incoming Account Balance LR event has a vehicle id that has not been seen in
					// any of the configured expressways, then we will ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) &&
						(LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) &&
						((LRE.vehicleId in _vehicleExpresswayInfoCache) == false)) {
						_unconfiguredExpresswayType2EventsReceived++;
						return;	
					}
					
					// As soon as we receive an LR event, we must record the event reception time.
					// This will be used later to calculate the time we are going to take in processing this event.
					LRE.eventRxTimestamp = getSeconds(getTimestamp());
					_eventCnt++;
					// Let us keep a copy of the most recently received event in a state variable.
					// This will be used to print the very last tuple that came from the data feeder when
					// the entire Linear Road processing is completed.
					assignFrom(_mostRecentlyReceivedEvent, LRE);
					
					// Always print the very first event.
					// After that, print only once for every 500K events.
					if ((_eventCnt == 1ul) || ((_eventCnt % 500000ul) == 0ul))  {
						if (_eventCnt == 1ul) {
							appTrc(Trace.error, "******* START OF LINEAR ROAD PROCESSING (main application entry point) *******");
						}
					
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)LRE);
					}

					// Now, route it to the appropriate event processor based on the event type.
					if (LRE.eventType == $POSTION_REPORT_EVENT) {
						// Store in which expressway a given vehicle is traveling now.
						// This is needed for routing the type 2 account balance queries to the 
						// correct type 0 event processor's parallel channel. See more comments in the
						// following "else if" block.						
						_vehicleExpresswayInfoTuple.expressWayNumber = LRE.expressWayNumber;
						_vehicleExpresswayInfoTuple.directionIndicator = LRE.directionIndicator;
						insertM(_vehicleExpresswayInfoCache, LRE.vehicleId, _vehicleExpresswayInfoTuple);
						submit(LRE, PositionReport_4);
					} else if (LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) {
						// Please note that any account balance query will have to be routed via
						// the position report event processor in order to maintain the tuple arrival order.
						// That will allow the position report event processor to be ready with the
						// balance for a given vehicle by the time the account balance (type 2) query
						// hits this Streams application. So, send a type 2 event to the type 0 event
						// processor which in turn will forward that type 2 event to the correct
						// account balance event processor below.
						// If we don't route a type 2 event via the type 0 event processor, then it will
						// cause cache misses in the DPS store by getting ahead of a more recent type 0
						// event that is still waiting inside the input queue of the very busy position
						// report event processor. Hence, let us make this type 2 event sojourn inside
						// the PositionReportEventProcessor for a little while before it is forwarded from
						// there to its own Type 2 event processor.
						//
						// This is going to be tricky since account balance queries are done only by
						// sending us the vehicle id. So, we have to simply know in which expressway and
						// direction that vehicle was seen last and route this type 2 event to a specific
						// instance of the position report event processor PE. That is why, we are maintaining
						// a separate map to find out a given vehicle's last known expressway and direction.
						//
						if (LRE.vehicleId in _vehicleExpresswayInfoCache) {
							// Assign the last known expressway and direction indicator for this vehicle.
							// With these values, it will land in the correct type 0 event processor where this
							// vehicle is already getting processed. We want this type 2 event to line up
							// behind those type 0 events belonging to a given vehicle.
							LRE.expressWayNumber =  _vehicleExpresswayInfoCache[LRE.vehicleId].expressWayNumber;
							LRE.directionIndicator = _vehicleExpresswayInfoCache[LRE.vehicleId].directionIndicator;
						} else {
							// This vehicle has not yet sent its very first position report to us.
							// That means, a type 2 event is coming much before the very first type 0 event for
							// that vehicle is sent to our application. (This can be double-checked in the data set.)
							// In such cases, we will simply send it to the very first position report event processor that
							// is handling expressway 0 and direction indicatior 0 (eastbound) to get forwarded from
							// there to the type 2 event processor.
							LRE.expressWayNumber =  30;
							LRE.directionIndicator = 0;
						}

						// It will now get shuttled to a particular channel of the PositionReportEventProcessor's parallel
						// region and then get forwarded from there to the type 2 event processor thereby putting it
						// in the right spot to obtain and respond with the most recently updated account balance for
						// a given vehicle. 
						submit(LRE, PositionReport_4);
					} else if (LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) {
						// LR specification says, we should respond to a type 3 event only for those days that were in the past.
						// If this type 3 event asks about the daily expenditure for today i.e. dayInThePast = 0,
						// we can simply ignore it by not sending any response back.
						if (LRE.dayInThePast > 0) {
							submit(LRE, DailyExpenditure4);
						} else {
							// Ignore a type 3 event that is asking about the daily expenditure for the current day.
							appTrc(Trace.debug, "_X_DDDDDDDDDDDDDD (Inside the event splitter operator) " +
								"Ignoring the type 3 event asking for daily expenditure with dayInThePast set to 0." +
								" Incoming Type 3 Event=" + (rstring)LRE);
						}
					}
				}
				
				onTuple TS: {
					// Let us see if the entire processing had ended so that we can print a closing line in the log file.
					if ((_eventCnt <= 0ul) || (_linearRoadProcessingEnded == true)) {
						// If the application run has not even started, nothing to do here and simply return back.
						// Do the same thing when the linear road processing had already ended.
						return;
					}
					
					if (_lastKnownEventCnt < _eventCnt) {
						// Linear road processing is actively in progress. Let us keep it going.
						_lastKnownEventCnt = _eventCnt;
					} else if (_lastKnownEventCnt == _eventCnt) {
						// Event count has not changed since we last visited here.
						// That means, Linear Road processing must have ended.
						// Let us print the final message in the PE log.
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)_mostRecentlyReceivedEvent);
						appTrc(Trace.error, "Empty event tuple error count = " + (rstring)_emptyEventsReceivedErrorCnt);
						appTrc(Trace.error, "Type 0 and 3 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType0AndType3EventsReceived);
						appTrc(Trace.error, "Type 2 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType2EventsReceived);
						appTrc(Trace.error, "******* END OF LINEAR ROAD PROCESSING (main application entry point) *******");
						_linearRoadProcessingEnded = true;
					} 
				}
				
			config
				threadedPort: queue(LRE, Sys.Wait);
				// Fuse it with the LR-DataReceiver partition.
				placement: host(lrPool[3]), partitionColocation("LR-DataReceiver4");
		}
		
		// We will split the type 0 position report events to go to the individual instances of
		// the type 0 event processor operator based on a unique combination of
		// "expressWayNumber + directionIndicator".
		<% my $cnt = 0; %>
		(
		 <% for ($cnt = 61; $cnt <= 80; $cnt++) { %>
		 stream<LinearRoadEventType> PositionReport<%=$cnt%><% if ($cnt < 80) { %>; <% }} %>
		) = Split(PositionReport_4 as PR) {				
			param
				file: getApplicationDir() +  "/etc/routing-map-for-type0-events-splitter4.txt";
				key: (rstring)PR.expressWayNumber + "_" + (rstring)PR.directionIndicator;

			config
				// Fuse it with the LR-DataReceiver partition.
				placement: partitionColocation("LR-DataReceiver4");
		} 
// ==================================================================
		// Bank 5
		// Linear Road scenario has 4 event types: 
		// 0) Position reports (real time a.k.a continuous query)
		// 2) Account balance (historical query)
		// 3) Daily expenditure report (historical query)
		// 4) Travel time estimation (historical query)
		//
		// In this application, we will only handle the first three event types and skip the fourth one.
		// Split the incoming data according to the event type in order for them to reach the 
		// appropriate downstream operators capable of processing a specific event.
		//
		// Incoming LR events will arrive here either directly from the data feeder (via TCP) or
		// from an asynchronous messaging system (via kafka).
		// 100x version --> Receive and route data for expressways 40 to 49
		(stream<LinearRoadEventType> PositionReport_5; stream<LinearRoadEventType> DailyExpenditure5) =
			Custom(LREventViaTcp5 as LRE; TimerSignal as TS) {
			logic
				state: {
					mutable uint64 _eventCnt = 0ul;
					mutable uint64 _lastKnownEventCnt = 0ul;
					mutable boolean _linearRoadProcessingEnded = false;
					mutable VehicleExpresswayInfoType _vehicleExpresswayInfoTuple = {};
					mutable map<int32, VehicleExpresswayInfoType> _vehicleExpresswayInfoCache = {};
					mutable LinearRoadEventType _mostRecentlyReceivedEvent = {};
					mutable int32 _emptyEventsReceivedErrorCnt = 0;
					mutable int32 _unconfiguredExpresswayType0AndType3EventsReceived = 0;
					mutable int32 _unconfiguredExpresswayType2EventsReceived = 0;
				}
				
				onTuple LRE: {
					// The LR Data feeder seems to send a completely empty event record with all the
					// attributes set to a value of 0. This happens when the data feeder reaches the
					// very end of the data file. We will catch that event with an invalid vehicleId
					// of 0 and discard it.
					if (LRE.vehicleId <= 0) {
						appTrc(Trace.debug, "_X_EEEEEEEEEEEEEEEEEEEEE (Inside the event splitter operator) " +
							"Received a tuple with an empty vehicle id right after the event " + 
							(rstring)_eventCnt + " and discarded it." +
							" Incoming Event=" + (rstring)LRE);		
						_emptyEventsReceivedErrorCnt++;				
						return;
					}

					// For the 15 xways and 25 xways, we will be using the 50 xways data set since 
					// we didn't generate separate data set files for 15x and 25x. In that case, we will
					// have to discard the LR events that are targetted for an unconfigured expressway.
					// That is what is being done in the next two if blocks.
					//					
					// If the incoming LR event is not for one of the configured expressways, then we can ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) && 
						(LRE.eventType == $POSTION_REPORT_EVENT || LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) && 
						(LRE.expressWayNumber >= <%=$totalNumberOfExpressways%>)) {
						// This LR event is for an expressway that is higher than
						// what is configured in this composite via a PERL variable.
						_unconfiguredExpresswayType0AndType3EventsReceived++;
						return;
					}
					
					// If the incoming Account Balance LR event has a vehicle id that has not been seen in
					// any of the configured expressways, then we will ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) &&
						(LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) &&
						((LRE.vehicleId in _vehicleExpresswayInfoCache) == false)) {
						_unconfiguredExpresswayType2EventsReceived++;
						return;	
					}
					
					// As soon as we receive an LR event, we must record the event reception time.
					// This will be used later to calculate the time we are going to take in processing this event.
					LRE.eventRxTimestamp = getSeconds(getTimestamp());
					_eventCnt++;
					// Let us keep a copy of the most recently received event in a state variable.
					// This will be used to print the very last tuple that came from the data feeder when
					// the entire Linear Road processing is completed.
					assignFrom(_mostRecentlyReceivedEvent, LRE);
					
					// Always print the very first event.
					// After that, print only once for every 500K events.
					if ((_eventCnt == 1ul) || ((_eventCnt % 500000ul) == 0ul))  {
						if (_eventCnt == 1ul) {
							appTrc(Trace.error, "******* START OF LINEAR ROAD PROCESSING (main application entry point) *******");
						}
					
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)LRE);
					}

					// Now, route it to the appropriate event processor based on the event type.
					if (LRE.eventType == $POSTION_REPORT_EVENT) {
						// Store in which expressway a given vehicle is traveling now.
						// This is needed for routing the type 2 account balance queries to the 
						// correct type 0 event processor's parallel channel. See more comments in the
						// following "else if" block.						
						_vehicleExpresswayInfoTuple.expressWayNumber = LRE.expressWayNumber;
						_vehicleExpresswayInfoTuple.directionIndicator = LRE.directionIndicator;
						insertM(_vehicleExpresswayInfoCache, LRE.vehicleId, _vehicleExpresswayInfoTuple);
						submit(LRE, PositionReport_5);
					} else if (LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) {
						// Please note that any account balance query will have to be routed via
						// the position report event processor in order to maintain the tuple arrival order.
						// That will allow the position report event processor to be ready with the
						// balance for a given vehicle by the time the account balance (type 2) query
						// hits this Streams application. So, send a type 2 event to the type 0 event
						// processor which in turn will forward that type 2 event to the correct
						// account balance event processor below.
						// If we don't route a type 2 event via the type 0 event processor, then it will
						// cause cache misses in the DPS store by getting ahead of a more recent type 0
						// event that is still waiting inside the input queue of the very busy position
						// report event processor. Hence, let us make this type 2 event sojourn inside
						// the PositionReportEventProcessor for a little while before it is forwarded from
						// there to its own Type 2 event processor.
						//
						// This is going to be tricky since account balance queries are done only by
						// sending us the vehicle id. So, we have to simply know in which expressway and
						// direction that vehicle was seen last and route this type 2 event to a specific
						// instance of the position report event processor PE. That is why, we are maintaining
						// a separate map to find out a given vehicle's last known expressway and direction.
						//
						if (LRE.vehicleId in _vehicleExpresswayInfoCache) {
							// Assign the last known expressway and direction indicator for this vehicle.
							// With these values, it will land in the correct type 0 event processor where this
							// vehicle is already getting processed. We want this type 2 event to line up
							// behind those type 0 events belonging to a given vehicle.
							LRE.expressWayNumber =  _vehicleExpresswayInfoCache[LRE.vehicleId].expressWayNumber;
							LRE.directionIndicator = _vehicleExpresswayInfoCache[LRE.vehicleId].directionIndicator;
						} else {
							// This vehicle has not yet sent its very first position report to us.
							// That means, a type 2 event is coming much before the very first type 0 event for
							// that vehicle is sent to our application. (This can be double-checked in the data set.)
							// In such cases, we will simply send it to the very first position report event processor that
							// is handling expressway 0 and direction indicatior 0 (eastbound) to get forwarded from
							// there to the type 2 event processor.
							LRE.expressWayNumber =  40;
							LRE.directionIndicator = 0;
						}

						// It will now get shuttled to a particular channel of the PositionReportEventProcessor's parallel
						// region and then get forwarded from there to the type 2 event processor thereby putting it
						// in the right spot to obtain and respond with the most recently updated account balance for
						// a given vehicle. 
						submit(LRE, PositionReport_5);
					} else if (LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) {
						// LR specification says, we should respond to a type 3 event only for those days that were in the past.
						// If this type 3 event asks about the daily expenditure for today i.e. dayInThePast = 0,
						// we can simply ignore it by not sending any response back.
						if (LRE.dayInThePast > 0) {
							submit(LRE, DailyExpenditure5);
						} else {
							// Ignore a type 3 event that is asking about the daily expenditure for the current day.
							appTrc(Trace.debug, "_X_DDDDDDDDDDDDDD (Inside the event splitter operator) " +
								"Ignoring the type 3 event asking for daily expenditure with dayInThePast set to 0." +
								" Incoming Type 3 Event=" + (rstring)LRE);
						}
					}
				}
				
				onTuple TS: {
					// Let us see if the entire processing had ended so that we can print a closing line in the log file.
					if ((_eventCnt <= 0ul) || (_linearRoadProcessingEnded == true)) {
						// If the application run has not even started, nothing to do here and simply return back.
						// Do the same thing when the linear road processing had already ended.
						return;
					}
					
					if (_lastKnownEventCnt < _eventCnt) {
						// Linear road processing is actively in progress. Let us keep it going.
						_lastKnownEventCnt = _eventCnt;
					} else if (_lastKnownEventCnt == _eventCnt) {
						// Event count has not changed since we last visited here.
						// That means, Linear Road processing must have ended.
						// Let us print the final message in the PE log.
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)_mostRecentlyReceivedEvent);
						appTrc(Trace.error, "Empty event tuple error count = " + (rstring)_emptyEventsReceivedErrorCnt);
						appTrc(Trace.error, "Type 0 and 3 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType0AndType3EventsReceived);
						appTrc(Trace.error, "Type 2 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType2EventsReceived);
						appTrc(Trace.error, "******* END OF LINEAR ROAD PROCESSING (main application entry point) *******");
						_linearRoadProcessingEnded = true;
					} 
				}
				
			config
				threadedPort: queue(LRE, Sys.Wait);
				// Fuse it with the LR-DataReceiver partition.
				placement: host(lrPool[4]), partitionColocation("LR-DataReceiver5");
		}
		
		// We will split the type 0 position report events to go to the individual instances of
		// the type 0 event processor operator based on a unique combination of
		// "expressWayNumber + directionIndicator".
		<% my $cnt = 0; %>
		(
		 <% for ($cnt = 81; $cnt <= 100; $cnt++) { %>
		 stream<LinearRoadEventType> PositionReport<%=$cnt%><% if ($cnt < 100) { %>; <% }} %>
		) = Split(PositionReport_5 as PR) {				
			param
				file: getApplicationDir() +  "/etc/routing-map-for-type0-events-splitter5.txt";
				key: (rstring)PR.expressWayNumber + "_" + (rstring)PR.directionIndicator;

			config
				// Fuse it with the LR-DataReceiver partition.
				placement: partitionColocation("LR-DataReceiver5");
		} 
// ==================================================================
		// Bank 6
		// Linear Road scenario has 4 event types: 
		// 0) Position reports (real time a.k.a continuous query)
		// 2) Account balance (historical query)
		// 3) Daily expenditure report (historical query)
		// 4) Travel time estimation (historical query)
		//
		// In this application, we will only handle the first three event types and skip the fourth one.
		// Split the incoming data according to the event type in order for them to reach the 
		// appropriate downstream operators capable of processing a specific event.
		//
		// Incoming LR events will arrive here either directly from the data feeder (via TCP) or
		// from an asynchronous messaging system (via kafka).
		// 100x version --> Receive and route data for expressways 50 to 59
		(stream<LinearRoadEventType> PositionReport_6; stream<LinearRoadEventType> DailyExpenditure6) =
			Custom(LREventViaTcp6 as LRE; TimerSignal as TS) {
			logic
				state: {
					mutable uint64 _eventCnt = 0ul;
					mutable uint64 _lastKnownEventCnt = 0ul;
					mutable boolean _linearRoadProcessingEnded = false;
					mutable VehicleExpresswayInfoType _vehicleExpresswayInfoTuple = {};
					mutable map<int32, VehicleExpresswayInfoType> _vehicleExpresswayInfoCache = {};
					mutable LinearRoadEventType _mostRecentlyReceivedEvent = {};
					mutable int32 _emptyEventsReceivedErrorCnt = 0;
					mutable int32 _unconfiguredExpresswayType0AndType3EventsReceived = 0;
					mutable int32 _unconfiguredExpresswayType2EventsReceived = 0;
				}
				
				onTuple LRE: {
					// The LR Data feeder seems to send a completely empty event record with all the
					// attributes set to a value of 0. This happens when the data feeder reaches the
					// very end of the data file. We will catch that event with an invalid vehicleId
					// of 0 and discard it.
					if (LRE.vehicleId <= 0) {
						appTrc(Trace.debug, "_X_EEEEEEEEEEEEEEEEEEEEE (Inside the event splitter operator) " +
							"Received a tuple with an empty vehicle id right after the event " + 
							(rstring)_eventCnt + " and discarded it." +
							" Incoming Event=" + (rstring)LRE);		
						_emptyEventsReceivedErrorCnt++;				
						return;
					}

					// For the 15 xways and 25 xways, we will be using the 50 xways data set since 
					// we didn't generate separate data set files for 15x and 25x. In that case, we will
					// have to discard the LR events that are targetted for an unconfigured expressway.
					// That is what is being done in the next two if blocks.
					//					
					// If the incoming LR event is not for one of the configured expressways, then we can ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) && 
						(LRE.eventType == $POSTION_REPORT_EVENT || LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) && 
						(LRE.expressWayNumber >= <%=$totalNumberOfExpressways%>)) {
						// This LR event is for an expressway that is higher than
						// what is configured in this composite via a PERL variable.
						_unconfiguredExpresswayType0AndType3EventsReceived++;
						return;
					}
					
					// If the incoming Account Balance LR event has a vehicle id that has not been seen in
					// any of the configured expressways, then we will ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) &&
						(LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) &&
						((LRE.vehicleId in _vehicleExpresswayInfoCache) == false)) {
						_unconfiguredExpresswayType2EventsReceived++;
						return;	
					}
					
					// As soon as we receive an LR event, we must record the event reception time.
					// This will be used later to calculate the time we are going to take in processing this event.
					LRE.eventRxTimestamp = getSeconds(getTimestamp());
					_eventCnt++;
					// Let us keep a copy of the most recently received event in a state variable.
					// This will be used to print the very last tuple that came from the data feeder when
					// the entire Linear Road processing is completed.
					assignFrom(_mostRecentlyReceivedEvent, LRE);
					
					// Always print the very first event.
					// After that, print only once for every 500K events.
					if ((_eventCnt == 1ul) || ((_eventCnt % 500000ul) == 0ul))  {
						if (_eventCnt == 1ul) {
							appTrc(Trace.error, "******* START OF LINEAR ROAD PROCESSING (main application entry point) *******");
						}
					
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)LRE);
					}

					// Now, route it to the appropriate event processor based on the event type.
					if (LRE.eventType == $POSTION_REPORT_EVENT) {
						// Store in which expressway a given vehicle is traveling now.
						// This is needed for routing the type 2 account balance queries to the 
						// correct type 0 event processor's parallel channel. See more comments in the
						// following "else if" block.						
						_vehicleExpresswayInfoTuple.expressWayNumber = LRE.expressWayNumber;
						_vehicleExpresswayInfoTuple.directionIndicator = LRE.directionIndicator;
						insertM(_vehicleExpresswayInfoCache, LRE.vehicleId, _vehicleExpresswayInfoTuple);
						submit(LRE, PositionReport_6);
					} else if (LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) {
						// Please note that any account balance query will have to be routed via
						// the position report event processor in order to maintain the tuple arrival order.
						// That will allow the position report event processor to be ready with the
						// balance for a given vehicle by the time the account balance (type 2) query
						// hits this Streams application. So, send a type 2 event to the type 0 event
						// processor which in turn will forward that type 2 event to the correct
						// account balance event processor below.
						// If we don't route a type 2 event via the type 0 event processor, then it will
						// cause cache misses in the DPS store by getting ahead of a more recent type 0
						// event that is still waiting inside the input queue of the very busy position
						// report event processor. Hence, let us make this type 2 event sojourn inside
						// the PositionReportEventProcessor for a little while before it is forwarded from
						// there to its own Type 2 event processor.
						//
						// This is going to be tricky since account balance queries are done only by
						// sending us the vehicle id. So, we have to simply know in which expressway and
						// direction that vehicle was seen last and route this type 2 event to a specific
						// instance of the position report event processor PE. That is why, we are maintaining
						// a separate map to find out a given vehicle's last known expressway and direction.
						//
						if (LRE.vehicleId in _vehicleExpresswayInfoCache) {
							// Assign the last known expressway and direction indicator for this vehicle.
							// With these values, it will land in the correct type 0 event processor where this
							// vehicle is already getting processed. We want this type 2 event to line up
							// behind those type 0 events belonging to a given vehicle.
							LRE.expressWayNumber =  _vehicleExpresswayInfoCache[LRE.vehicleId].expressWayNumber;
							LRE.directionIndicator = _vehicleExpresswayInfoCache[LRE.vehicleId].directionIndicator;
						} else {
							// This vehicle has not yet sent its very first position report to us.
							// That means, a type 2 event is coming much before the very first type 0 event for
							// that vehicle is sent to our application. (This can be double-checked in the data set.)
							// In such cases, we will simply send it to the very first position report event processor that
							// is handling expressway 0 and direction indicatior 0 (eastbound) to get forwarded from
							// there to the type 2 event processor.
							LRE.expressWayNumber =  50;
							LRE.directionIndicator = 0;
						}

						// It will now get shuttled to a particular channel of the PositionReportEventProcessor's parallel
						// region and then get forwarded from there to the type 2 event processor thereby putting it
						// in the right spot to obtain and respond with the most recently updated account balance for
						// a given vehicle. 
						submit(LRE, PositionReport_6);
					} else if (LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) {
						// LR specification says, we should respond to a type 3 event only for those days that were in the past.
						// If this type 3 event asks about the daily expenditure for today i.e. dayInThePast = 0,
						// we can simply ignore it by not sending any response back.
						if (LRE.dayInThePast > 0) {
							submit(LRE, DailyExpenditure6);
						} else {
							// Ignore a type 3 event that is asking about the daily expenditure for the current day.
							appTrc(Trace.debug, "_X_DDDDDDDDDDDDDD (Inside the event splitter operator) " +
								"Ignoring the type 3 event asking for daily expenditure with dayInThePast set to 0." +
								" Incoming Type 3 Event=" + (rstring)LRE);
						}
					}
				}
				
				onTuple TS: {
					// Let us see if the entire processing had ended so that we can print a closing line in the log file.
					if ((_eventCnt <= 0ul) || (_linearRoadProcessingEnded == true)) {
						// If the application run has not even started, nothing to do here and simply return back.
						// Do the same thing when the linear road processing had already ended.
						return;
					}
					
					if (_lastKnownEventCnt < _eventCnt) {
						// Linear road processing is actively in progress. Let us keep it going.
						_lastKnownEventCnt = _eventCnt;
					} else if (_lastKnownEventCnt == _eventCnt) {
						// Event count has not changed since we last visited here.
						// That means, Linear Road processing must have ended.
						// Let us print the final message in the PE log.
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)_mostRecentlyReceivedEvent);
						appTrc(Trace.error, "Empty event tuple error count = " + (rstring)_emptyEventsReceivedErrorCnt);
						appTrc(Trace.error, "Type 0 and 3 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType0AndType3EventsReceived);
						appTrc(Trace.error, "Type 2 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType2EventsReceived);
						appTrc(Trace.error, "******* END OF LINEAR ROAD PROCESSING (main application entry point) *******");
						_linearRoadProcessingEnded = true;
					} 
				}
				
			config
				threadedPort: queue(LRE, Sys.Wait);
				// Fuse it with the LR-DataReceiver partition.
				placement: host(lrPool[0]), partitionColocation("LR-DataReceiver6");
		}
		
		// We will split the type 0 position report events to go to the individual instances of
		// the type 0 event processor operator based on a unique combination of
		// "expressWayNumber + directionIndicator".
		<% my $cnt = 0; %>
		(
		 <% for ($cnt = 101; $cnt <= 120; $cnt++) { %>
		 stream<LinearRoadEventType> PositionReport<%=$cnt%><% if ($cnt < 120) { %>; <% }} %>
		) = Split(PositionReport_6 as PR) {				
			param
				file: getApplicationDir() +  "/etc/routing-map-for-type0-events-splitter6.txt";
				key: (rstring)PR.expressWayNumber + "_" + (rstring)PR.directionIndicator;

			config
				// Fuse it with the LR-DataReceiver partition.
				placement: partitionColocation("LR-DataReceiver6");
		} 
// ==================================================================
		// Bank 7
		// Linear Road scenario has 4 event types: 
		// 0) Position reports (real time a.k.a continuous query)
		// 2) Account balance (historical query)
		// 3) Daily expenditure report (historical query)
		// 4) Travel time estimation (historical query)
		//
		// In this application, we will only handle the first three event types and skip the fourth one.
		// Split the incoming data according to the event type in order for them to reach the 
		// appropriate downstream operators capable of processing a specific event.
		//
		// Incoming LR events will arrive here either directly from the data feeder (via TCP) or
		// from an asynchronous messaging system (via kafka).
		// 100x version --> Receive and route data for expressways 60 to 69
		(stream<LinearRoadEventType> PositionReport_7; stream<LinearRoadEventType> DailyExpenditure7) =
			Custom(LREventViaTcp7 as LRE; TimerSignal as TS) {
			logic
				state: {
					mutable uint64 _eventCnt = 0ul;
					mutable uint64 _lastKnownEventCnt = 0ul;
					mutable boolean _linearRoadProcessingEnded = false;
					mutable VehicleExpresswayInfoType _vehicleExpresswayInfoTuple = {};
					mutable map<int32, VehicleExpresswayInfoType> _vehicleExpresswayInfoCache = {};
					mutable LinearRoadEventType _mostRecentlyReceivedEvent = {};
					mutable int32 _emptyEventsReceivedErrorCnt = 0;
					mutable int32 _unconfiguredExpresswayType0AndType3EventsReceived = 0;
					mutable int32 _unconfiguredExpresswayType2EventsReceived = 0;
				}
				
				onTuple LRE: {
					// The LR Data feeder seems to send a completely empty event record with all the
					// attributes set to a value of 0. This happens when the data feeder reaches the
					// very end of the data file. We will catch that event with an invalid vehicleId
					// of 0 and discard it.
					if (LRE.vehicleId <= 0) {
						appTrc(Trace.debug, "_X_EEEEEEEEEEEEEEEEEEEEE (Inside the event splitter operator) " +
							"Received a tuple with an empty vehicle id right after the event " + 
							(rstring)_eventCnt + " and discarded it." +
							" Incoming Event=" + (rstring)LRE);		
						_emptyEventsReceivedErrorCnt++;				
						return;
					}

					// For the 15 xways and 25 xways, we will be using the 50 xways data set since 
					// we didn't generate separate data set files for 15x and 25x. In that case, we will
					// have to discard the LR events that are targetted for an unconfigured expressway.
					// That is what is being done in the next two if blocks.
					//					
					// If the incoming LR event is not for one of the configured expressways, then we can ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) && 
						(LRE.eventType == $POSTION_REPORT_EVENT || LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) && 
						(LRE.expressWayNumber >= <%=$totalNumberOfExpressways%>)) {
						// This LR event is for an expressway that is higher than
						// what is configured in this composite via a PERL variable.
						_unconfiguredExpresswayType0AndType3EventsReceived++;
						return;
					}
					
					// If the incoming Account Balance LR event has a vehicle id that has not been seen in
					// any of the configured expressways, then we will ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) &&
						(LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) &&
						((LRE.vehicleId in _vehicleExpresswayInfoCache) == false)) {
						_unconfiguredExpresswayType2EventsReceived++;
						return;	
					}
					
					// As soon as we receive an LR event, we must record the event reception time.
					// This will be used later to calculate the time we are going to take in processing this event.
					LRE.eventRxTimestamp = getSeconds(getTimestamp());
					_eventCnt++;
					// Let us keep a copy of the most recently received event in a state variable.
					// This will be used to print the very last tuple that came from the data feeder when
					// the entire Linear Road processing is completed.
					assignFrom(_mostRecentlyReceivedEvent, LRE);
					
					// Always print the very first event.
					// After that, print only once for every 500K events.
					if ((_eventCnt == 1ul) || ((_eventCnt % 500000ul) == 0ul))  {
						if (_eventCnt == 1ul) {
							appTrc(Trace.error, "******* START OF LINEAR ROAD PROCESSING (main application entry point) *******");
						}
					
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)LRE);
					}

					// Now, route it to the appropriate event processor based on the event type.
					if (LRE.eventType == $POSTION_REPORT_EVENT) {
						// Store in which expressway a given vehicle is traveling now.
						// This is needed for routing the type 2 account balance queries to the 
						// correct type 0 event processor's parallel channel. See more comments in the
						// following "else if" block.						
						_vehicleExpresswayInfoTuple.expressWayNumber = LRE.expressWayNumber;
						_vehicleExpresswayInfoTuple.directionIndicator = LRE.directionIndicator;
						insertM(_vehicleExpresswayInfoCache, LRE.vehicleId, _vehicleExpresswayInfoTuple);
						submit(LRE, PositionReport_7);
					} else if (LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) {
						// Please note that any account balance query will have to be routed via
						// the position report event processor in order to maintain the tuple arrival order.
						// That will allow the position report event processor to be ready with the
						// balance for a given vehicle by the time the account balance (type 2) query
						// hits this Streams application. So, send a type 2 event to the type 0 event
						// processor which in turn will forward that type 2 event to the correct
						// account balance event processor below.
						// If we don't route a type 2 event via the type 0 event processor, then it will
						// cause cache misses in the DPS store by getting ahead of a more recent type 0
						// event that is still waiting inside the input queue of the very busy position
						// report event processor. Hence, let us make this type 2 event sojourn inside
						// the PositionReportEventProcessor for a little while before it is forwarded from
						// there to its own Type 2 event processor.
						//
						// This is going to be tricky since account balance queries are done only by
						// sending us the vehicle id. So, we have to simply know in which expressway and
						// direction that vehicle was seen last and route this type 2 event to a specific
						// instance of the position report event processor PE. That is why, we are maintaining
						// a separate map to find out a given vehicle's last known expressway and direction.
						//
						if (LRE.vehicleId in _vehicleExpresswayInfoCache) {
							// Assign the last known expressway and direction indicator for this vehicle.
							// With these values, it will land in the correct type 0 event processor where this
							// vehicle is already getting processed. We want this type 2 event to line up
							// behind those type 0 events belonging to a given vehicle.
							LRE.expressWayNumber =  _vehicleExpresswayInfoCache[LRE.vehicleId].expressWayNumber;
							LRE.directionIndicator = _vehicleExpresswayInfoCache[LRE.vehicleId].directionIndicator;
						} else {
							// This vehicle has not yet sent its very first position report to us.
							// That means, a type 2 event is coming much before the very first type 0 event for
							// that vehicle is sent to our application. (This can be double-checked in the data set.)
							// In such cases, we will simply send it to the very first position report event processor that
							// is handling expressway 0 and direction indicatior 0 (eastbound) to get forwarded from
							// there to the type 2 event processor.
							LRE.expressWayNumber =  60;
							LRE.directionIndicator = 0;
						}

						// It will now get shuttled to a particular channel of the PositionReportEventProcessor's parallel
						// region and then get forwarded from there to the type 2 event processor thereby putting it
						// in the right spot to obtain and respond with the most recently updated account balance for
						// a given vehicle. 
						submit(LRE, PositionReport_7);
					} else if (LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) {
						// LR specification says, we should respond to a type 3 event only for those days that were in the past.
						// If this type 3 event asks about the daily expenditure for today i.e. dayInThePast = 0,
						// we can simply ignore it by not sending any response back.
						if (LRE.dayInThePast > 0) {
							submit(LRE, DailyExpenditure7);
						} else {
							// Ignore a type 3 event that is asking about the daily expenditure for the current day.
							appTrc(Trace.debug, "_X_DDDDDDDDDDDDDD (Inside the event splitter operator) " +
								"Ignoring the type 3 event asking for daily expenditure with dayInThePast set to 0." +
								" Incoming Type 3 Event=" + (rstring)LRE);
						}
					}
				}
				
				onTuple TS: {
					// Let us see if the entire processing had ended so that we can print a closing line in the log file.
					if ((_eventCnt <= 0ul) || (_linearRoadProcessingEnded == true)) {
						// If the application run has not even started, nothing to do here and simply return back.
						// Do the same thing when the linear road processing had already ended.
						return;
					}
					
					if (_lastKnownEventCnt < _eventCnt) {
						// Linear road processing is actively in progress. Let us keep it going.
						_lastKnownEventCnt = _eventCnt;
					} else if (_lastKnownEventCnt == _eventCnt) {
						// Event count has not changed since we last visited here.
						// That means, Linear Road processing must have ended.
						// Let us print the final message in the PE log.
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)_mostRecentlyReceivedEvent);
						appTrc(Trace.error, "Empty event tuple error count = " + (rstring)_emptyEventsReceivedErrorCnt);
						appTrc(Trace.error, "Type 0 and 3 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType0AndType3EventsReceived);
						appTrc(Trace.error, "Type 2 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType2EventsReceived);
						appTrc(Trace.error, "******* END OF LINEAR ROAD PROCESSING (main application entry point) *******");
						_linearRoadProcessingEnded = true;
					} 
				}
				
			config
				threadedPort: queue(LRE, Sys.Wait);
				// Fuse it with the LR-DataReceiver partition.
				placement: host(lrPool[1]), partitionColocation("LR-DataReceiver7");
		}
		
		// We will split the type 0 position report events to go to the individual instances of
		// the type 0 event processor operator based on a unique combination of
		// "expressWayNumber + directionIndicator".
		<% my $cnt = 0; %>
		(
		 <% for ($cnt = 121; $cnt <= 140; $cnt++) { %>
		 stream<LinearRoadEventType> PositionReport<%=$cnt%><% if ($cnt < 140) { %>; <% }} %>
		) = Split(PositionReport_7 as PR) {				
			param
				file: getApplicationDir() +  "/etc/routing-map-for-type0-events-splitter7.txt";
				key: (rstring)PR.expressWayNumber + "_" + (rstring)PR.directionIndicator;

			config
				// Fuse it with the LR-DataReceiver partition.
				placement: partitionColocation("LR-DataReceiver7");
		} 

// ==================================================================
		// Bank 8
		// Linear Road scenario has 4 event types: 
		// 0) Position reports (real time a.k.a continuous query)
		// 2) Account balance (historical query)
		// 3) Daily expenditure report (historical query)
		// 4) Travel time estimation (historical query)
		//
		// In this application, we will only handle the first three event types and skip the fourth one.
		// Split the incoming data according to the event type in order for them to reach the 
		// appropriate downstream operators capable of processing a specific event.
		//
		// Incoming LR events will arrive here either directly from the data feeder (via TCP) or
		// from an asynchronous messaging system (via kafka).
		// 100x version --> Receive and route data for expressways 70 to 79
		(stream<LinearRoadEventType> PositionReport_8; stream<LinearRoadEventType> DailyExpenditure8) =
			Custom(LREventViaTcp8 as LRE; TimerSignal as TS) {
			logic
				state: {
					mutable uint64 _eventCnt = 0ul;
					mutable uint64 _lastKnownEventCnt = 0ul;
					mutable boolean _linearRoadProcessingEnded = false;
					mutable VehicleExpresswayInfoType _vehicleExpresswayInfoTuple = {};
					mutable map<int32, VehicleExpresswayInfoType> _vehicleExpresswayInfoCache = {};
					mutable LinearRoadEventType _mostRecentlyReceivedEvent = {};
					mutable int32 _emptyEventsReceivedErrorCnt = 0;
					mutable int32 _unconfiguredExpresswayType0AndType3EventsReceived = 0;
					mutable int32 _unconfiguredExpresswayType2EventsReceived = 0;
				}
				
				onTuple LRE: {
					// The LR Data feeder seems to send a completely empty event record with all the
					// attributes set to a value of 0. This happens when the data feeder reaches the
					// very end of the data file. We will catch that event with an invalid vehicleId
					// of 0 and discard it.
					if (LRE.vehicleId <= 0) {
						appTrc(Trace.debug, "_X_EEEEEEEEEEEEEEEEEEEEE (Inside the event splitter operator) " +
							"Received a tuple with an empty vehicle id right after the event " + 
							(rstring)_eventCnt + " and discarded it." +
							" Incoming Event=" + (rstring)LRE);		
						_emptyEventsReceivedErrorCnt++;				
						return;
					}

					// For the 15 xways and 25 xways, we will be using the 50 xways data set since 
					// we didn't generate separate data set files for 15x and 25x. In that case, we will
					// have to discard the LR events that are targetted for an unconfigured expressway.
					// That is what is being done in the next two if blocks.
					//					
					// If the incoming LR event is not for one of the configured expressways, then we can ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) && 
						(LRE.eventType == $POSTION_REPORT_EVENT || LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) && 
						(LRE.expressWayNumber >= <%=$totalNumberOfExpressways%>)) {
						// This LR event is for an expressway that is higher than
						// what is configured in this composite via a PERL variable.
						_unconfiguredExpresswayType0AndType3EventsReceived++;
						return;
					}
					
					// If the incoming Account Balance LR event has a vehicle id that has not been seen in
					// any of the configured expressways, then we will ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) &&
						(LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) &&
						((LRE.vehicleId in _vehicleExpresswayInfoCache) == false)) {
						_unconfiguredExpresswayType2EventsReceived++;
						return;	
					}
					
					// As soon as we receive an LR event, we must record the event reception time.
					// This will be used later to calculate the time we are going to take in processing this event.
					LRE.eventRxTimestamp = getSeconds(getTimestamp());
					_eventCnt++;
					// Let us keep a copy of the most recently received event in a state variable.
					// This will be used to print the very last tuple that came from the data feeder when
					// the entire Linear Road processing is completed.
					assignFrom(_mostRecentlyReceivedEvent, LRE);
					
					// Always print the very first event.
					// After that, print only once for every 500K events.
					if ((_eventCnt == 1ul) || ((_eventCnt % 500000ul) == 0ul))  {
						if (_eventCnt == 1ul) {
							appTrc(Trace.error, "******* START OF LINEAR ROAD PROCESSING (main application entry point) *******");
						}
					
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)LRE);
					}

					// Now, route it to the appropriate event processor based on the event type.
					if (LRE.eventType == $POSTION_REPORT_EVENT) {
						// Store in which expressway a given vehicle is traveling now.
						// This is needed for routing the type 2 account balance queries to the 
						// correct type 0 event processor's parallel channel. See more comments in the
						// following "else if" block.						
						_vehicleExpresswayInfoTuple.expressWayNumber = LRE.expressWayNumber;
						_vehicleExpresswayInfoTuple.directionIndicator = LRE.directionIndicator;
						insertM(_vehicleExpresswayInfoCache, LRE.vehicleId, _vehicleExpresswayInfoTuple);
						submit(LRE, PositionReport_8);
					} else if (LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) {
						// Please note that any account balance query will have to be routed via
						// the position report event processor in order to maintain the tuple arrival order.
						// That will allow the position report event processor to be ready with the
						// balance for a given vehicle by the time the account balance (type 2) query
						// hits this Streams application. So, send a type 2 event to the type 0 event
						// processor which in turn will forward that type 2 event to the correct
						// account balance event processor below.
						// If we don't route a type 2 event via the type 0 event processor, then it will
						// cause cache misses in the DPS store by getting ahead of a more recent type 0
						// event that is still waiting inside the input queue of the very busy position
						// report event processor. Hence, let us make this type 2 event sojourn inside
						// the PositionReportEventProcessor for a little while before it is forwarded from
						// there to its own Type 2 event processor.
						//
						// This is going to be tricky since account balance queries are done only by
						// sending us the vehicle id. So, we have to simply know in which expressway and
						// direction that vehicle was seen last and route this type 2 event to a specific
						// instance of the position report event processor PE. That is why, we are maintaining
						// a separate map to find out a given vehicle's last known expressway and direction.
						//
						if (LRE.vehicleId in _vehicleExpresswayInfoCache) {
							// Assign the last known expressway and direction indicator for this vehicle.
							// With these values, it will land in the correct type 0 event processor where this
							// vehicle is already getting processed. We want this type 2 event to line up
							// behind those type 0 events belonging to a given vehicle.
							LRE.expressWayNumber =  _vehicleExpresswayInfoCache[LRE.vehicleId].expressWayNumber;
							LRE.directionIndicator = _vehicleExpresswayInfoCache[LRE.vehicleId].directionIndicator;
						} else {
							// This vehicle has not yet sent its very first position report to us.
							// That means, a type 2 event is coming much before the very first type 0 event for
							// that vehicle is sent to our application. (This can be double-checked in the data set.)
							// In such cases, we will simply send it to the very first position report event processor that
							// is handling expressway 0 and direction indicatior 0 (eastbound) to get forwarded from
							// there to the type 2 event processor.
							LRE.expressWayNumber =  70;
							LRE.directionIndicator = 0;
						}

						// It will now get shuttled to a particular channel of the PositionReportEventProcessor's parallel
						// region and then get forwarded from there to the type 2 event processor thereby putting it
						// in the right spot to obtain and respond with the most recently updated account balance for
						// a given vehicle. 
						submit(LRE, PositionReport_8);
					} else if (LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) {
						// LR specification says, we should respond to a type 3 event only for those days that were in the past.
						// If this type 3 event asks about the daily expenditure for today i.e. dayInThePast = 0,
						// we can simply ignore it by not sending any response back.
						if (LRE.dayInThePast > 0) {
							submit(LRE, DailyExpenditure8);
						} else {
							// Ignore a type 3 event that is asking about the daily expenditure for the current day.
							appTrc(Trace.debug, "_X_DDDDDDDDDDDDDD (Inside the event splitter operator) " +
								"Ignoring the type 3 event asking for daily expenditure with dayInThePast set to 0." +
								" Incoming Type 3 Event=" + (rstring)LRE);
						}
					}
				}
				
				onTuple TS: {
					// Let us see if the entire processing had ended so that we can print a closing line in the log file.
					if ((_eventCnt <= 0ul) || (_linearRoadProcessingEnded == true)) {
						// If the application run has not even started, nothing to do here and simply return back.
						// Do the same thing when the linear road processing had already ended.
						return;
					}
					
					if (_lastKnownEventCnt < _eventCnt) {
						// Linear road processing is actively in progress. Let us keep it going.
						_lastKnownEventCnt = _eventCnt;
					} else if (_lastKnownEventCnt == _eventCnt) {
						// Event count has not changed since we last visited here.
						// That means, Linear Road processing must have ended.
						// Let us print the final message in the PE log.
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)_mostRecentlyReceivedEvent);
						appTrc(Trace.error, "Empty event tuple error count = " + (rstring)_emptyEventsReceivedErrorCnt);
						appTrc(Trace.error, "Type 0 and 3 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType0AndType3EventsReceived);
						appTrc(Trace.error, "Type 2 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType2EventsReceived);
						appTrc(Trace.error, "******* END OF LINEAR ROAD PROCESSING (main application entry point) *******");
						_linearRoadProcessingEnded = true;
					} 
				}
				
			config
				threadedPort: queue(LRE, Sys.Wait);
				// Fuse it with the LR-DataReceiver partition.
				placement: host(lrPool[3]), partitionColocation("LR-DataReceiver8");
		}
		
		// We will split the type 0 position report events to go to the individual instances of
		// the type 0 event processor operator based on a unique combination of
		// "expressWayNumber + directionIndicator".
		<% my $cnt = 0; %>
		(
		 <% for ($cnt = 141; $cnt <= 160; $cnt++) { %>
		 stream<LinearRoadEventType> PositionReport<%=$cnt%><% if ($cnt < 160) { %>; <% }} %>
		) = Split(PositionReport_8 as PR) {				
			param
				file: getApplicationDir() +  "/etc/routing-map-for-type0-events-splitter8.txt";
				key: (rstring)PR.expressWayNumber + "_" + (rstring)PR.directionIndicator;

			config
				// Fuse it with the LR-DataReceiver partition.
				placement: partitionColocation("LR-DataReceiver8");
		} 
// ==================================================================
		// Bank 9
		// Linear Road scenario has 4 event types: 
		// 0) Position reports (real time a.k.a continuous query)
		// 2) Account balance (historical query)
		// 3) Daily expenditure report (historical query)
		// 4) Travel time estimation (historical query)
		//
		// In this application, we will only handle the first three event types and skip the fourth one.
		// Split the incoming data according to the event type in order for them to reach the 
		// appropriate downstream operators capable of processing a specific event.
		//
		// Incoming LR events will arrive here either directly from the data feeder (via TCP) or
		// from an asynchronous messaging system (via kafka).
		// 100x version --> Receive and route data for expressways 80 to 89
		(stream<LinearRoadEventType> PositionReport_9; stream<LinearRoadEventType> DailyExpenditure9) =
			Custom(LREventViaTcp9 as LRE; TimerSignal as TS) {
			logic
				state: {
					mutable uint64 _eventCnt = 0ul;
					mutable uint64 _lastKnownEventCnt = 0ul;
					mutable boolean _linearRoadProcessingEnded = false;
					mutable VehicleExpresswayInfoType _vehicleExpresswayInfoTuple = {};
					mutable map<int32, VehicleExpresswayInfoType> _vehicleExpresswayInfoCache = {};
					mutable LinearRoadEventType _mostRecentlyReceivedEvent = {};
					mutable int32 _emptyEventsReceivedErrorCnt = 0;
					mutable int32 _unconfiguredExpresswayType0AndType3EventsReceived = 0;
					mutable int32 _unconfiguredExpresswayType2EventsReceived = 0;
				}
				
				onTuple LRE: {
					// The LR Data feeder seems to send a completely empty event record with all the
					// attributes set to a value of 0. This happens when the data feeder reaches the
					// very end of the data file. We will catch that event with an invalid vehicleId
					// of 0 and discard it.
					if (LRE.vehicleId <= 0) {
						appTrc(Trace.debug, "_X_EEEEEEEEEEEEEEEEEEEEE (Inside the event splitter operator) " +
							"Received a tuple with an empty vehicle id right after the event " + 
							(rstring)_eventCnt + " and discarded it." +
							" Incoming Event=" + (rstring)LRE);		
						_emptyEventsReceivedErrorCnt++;				
						return;
					}

					// For the 15 xways and 25 xways, we will be using the 50 xways data set since 
					// we didn't generate separate data set files for 15x and 25x. In that case, we will
					// have to discard the LR events that are targetted for an unconfigured expressway.
					// That is what is being done in the next two if blocks.
					//					
					// If the incoming LR event is not for one of the configured expressways, then we can ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) && 
						(LRE.eventType == $POSTION_REPORT_EVENT || LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) && 
						(LRE.expressWayNumber >= <%=$totalNumberOfExpressways%>)) {
						// This LR event is for an expressway that is higher than
						// what is configured in this composite via a PERL variable.
						_unconfiguredExpresswayType0AndType3EventsReceived++;
						return;
					}
					
					// If the incoming Account Balance LR event has a vehicle id that has not been seen in
					// any of the configured expressways, then we will ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) &&
						(LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) &&
						((LRE.vehicleId in _vehicleExpresswayInfoCache) == false)) {
						_unconfiguredExpresswayType2EventsReceived++;
						return;	
					}
					
					// As soon as we receive an LR event, we must record the event reception time.
					// This will be used later to calculate the time we are going to take in processing this event.
					LRE.eventRxTimestamp = getSeconds(getTimestamp());
					_eventCnt++;
					// Let us keep a copy of the most recently received event in a state variable.
					// This will be used to print the very last tuple that came from the data feeder when
					// the entire Linear Road processing is completed.
					assignFrom(_mostRecentlyReceivedEvent, LRE);
					
					// Always print the very first event.
					// After that, print only once for every 500K events.
					if ((_eventCnt == 1ul) || ((_eventCnt % 500000ul) == 0ul))  {
						if (_eventCnt == 1ul) {
							appTrc(Trace.error, "******* START OF LINEAR ROAD PROCESSING (main application entry point) *******");
						}
					
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)LRE);
					}

					// Now, route it to the appropriate event processor based on the event type.
					if (LRE.eventType == $POSTION_REPORT_EVENT) {
						// Store in which expressway a given vehicle is traveling now.
						// This is needed for routing the type 2 account balance queries to the 
						// correct type 0 event processor's parallel channel. See more comments in the
						// following "else if" block.						
						_vehicleExpresswayInfoTuple.expressWayNumber = LRE.expressWayNumber;
						_vehicleExpresswayInfoTuple.directionIndicator = LRE.directionIndicator;
						insertM(_vehicleExpresswayInfoCache, LRE.vehicleId, _vehicleExpresswayInfoTuple);
						submit(LRE, PositionReport_9);
					} else if (LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) {
						// Please note that any account balance query will have to be routed via
						// the position report event processor in order to maintain the tuple arrival order.
						// That will allow the position report event processor to be ready with the
						// balance for a given vehicle by the time the account balance (type 2) query
						// hits this Streams application. So, send a type 2 event to the type 0 event
						// processor which in turn will forward that type 2 event to the correct
						// account balance event processor below.
						// If we don't route a type 2 event via the type 0 event processor, then it will
						// cause cache misses in the DPS store by getting ahead of a more recent type 0
						// event that is still waiting inside the input queue of the very busy position
						// report event processor. Hence, let us make this type 2 event sojourn inside
						// the PositionReportEventProcessor for a little while before it is forwarded from
						// there to its own Type 2 event processor.
						//
						// This is going to be tricky since account balance queries are done only by
						// sending us the vehicle id. So, we have to simply know in which expressway and
						// direction that vehicle was seen last and route this type 2 event to a specific
						// instance of the position report event processor PE. That is why, we are maintaining
						// a separate map to find out a given vehicle's last known expressway and direction.
						//
						if (LRE.vehicleId in _vehicleExpresswayInfoCache) {
							// Assign the last known expressway and direction indicator for this vehicle.
							// With these values, it will land in the correct type 0 event processor where this
							// vehicle is already getting processed. We want this type 2 event to line up
							// behind those type 0 events belonging to a given vehicle.
							LRE.expressWayNumber =  _vehicleExpresswayInfoCache[LRE.vehicleId].expressWayNumber;
							LRE.directionIndicator = _vehicleExpresswayInfoCache[LRE.vehicleId].directionIndicator;
						} else {
							// This vehicle has not yet sent its very first position report to us.
							// That means, a type 2 event is coming much before the very first type 0 event for
							// that vehicle is sent to our application. (This can be double-checked in the data set.)
							// In such cases, we will simply send it to the very first position report event processor that
							// is handling expressway 0 and direction indicatior 0 (eastbound) to get forwarded from
							// there to the type 2 event processor.
							LRE.expressWayNumber =  80;
							LRE.directionIndicator = 0;
						}

						// It will now get shuttled to a particular channel of the PositionReportEventProcessor's parallel
						// region and then get forwarded from there to the type 2 event processor thereby putting it
						// in the right spot to obtain and respond with the most recently updated account balance for
						// a given vehicle. 
						submit(LRE, PositionReport_9);
					} else if (LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) {
						// LR specification says, we should respond to a type 3 event only for those days that were in the past.
						// If this type 3 event asks about the daily expenditure for today i.e. dayInThePast = 0,
						// we can simply ignore it by not sending any response back.
						if (LRE.dayInThePast > 0) {
							submit(LRE, DailyExpenditure9);
						} else {
							// Ignore a type 3 event that is asking about the daily expenditure for the current day.
							appTrc(Trace.debug, "_X_DDDDDDDDDDDDDD (Inside the event splitter operator) " +
								"Ignoring the type 3 event asking for daily expenditure with dayInThePast set to 0." +
								" Incoming Type 3 Event=" + (rstring)LRE);
						}
					}
				}
				
				onTuple TS: {
					// Let us see if the entire processing had ended so that we can print a closing line in the log file.
					if ((_eventCnt <= 0ul) || (_linearRoadProcessingEnded == true)) {
						// If the application run has not even started, nothing to do here and simply return back.
						// Do the same thing when the linear road processing had already ended.
						return;
					}
					
					if (_lastKnownEventCnt < _eventCnt) {
						// Linear road processing is actively in progress. Let us keep it going.
						_lastKnownEventCnt = _eventCnt;
					} else if (_lastKnownEventCnt == _eventCnt) {
						// Event count has not changed since we last visited here.
						// That means, Linear Road processing must have ended.
						// Let us print the final message in the PE log.
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)_mostRecentlyReceivedEvent);
						appTrc(Trace.error, "Empty event tuple error count = " + (rstring)_emptyEventsReceivedErrorCnt);
						appTrc(Trace.error, "Type 0 and 3 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType0AndType3EventsReceived);
						appTrc(Trace.error, "Type 2 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType2EventsReceived);
						appTrc(Trace.error, "******* END OF LINEAR ROAD PROCESSING (main application entry point) *******");
						_linearRoadProcessingEnded = true;
					} 
				}
				
			config
				threadedPort: queue(LRE, Sys.Wait);
				// Fuse it with the LR-DataReceiver partition.
				placement: host(lrPool[4]), partitionColocation("LR-DataReceiver9");
		}
		
		// We will split the type 0 position report events to go to the individual instances of
		// the type 0 event processor operator based on a unique combination of
		// "expressWayNumber + directionIndicator".
		<% my $cnt = 0; %>
		(
		 <% for ($cnt = 161; $cnt <= 180; $cnt++) { %>
		 stream<LinearRoadEventType> PositionReport<%=$cnt%><% if ($cnt < 180) { %>; <% }} %>
		) = Split(PositionReport_9 as PR) {				
			param
				file: getApplicationDir() +  "/etc/routing-map-for-type0-events-splitter9.txt";
				key: (rstring)PR.expressWayNumber + "_" + (rstring)PR.directionIndicator;

			config
				// Fuse it with the LR-DataReceiver partition.
				placement: partitionColocation("LR-DataReceiver9");
		} 

// ==================================================================
		// Bank 10
		// Linear Road scenario has 4 event types: 
		// 0) Position reports (real time a.k.a continuous query)
		// 2) Account balance (historical query)
		// 3) Daily expenditure report (historical query)
		// 4) Travel time estimation (historical query)
		//
		// In this application, we will only handle the first three event types and skip the fourth one.
		// Split the incoming data according to the event type in order for them to reach the 
		// appropriate downstream operators capable of processing a specific event.
		//
		// Incoming LR events will arrive here either directly from the data feeder (via TCP) or
		// from an asynchronous messaging system (via kafka).
		// 100x version --> Receive and route data for expressways 90 to 99
		(stream<LinearRoadEventType> PositionReport_10; stream<LinearRoadEventType> DailyExpenditure10) =
			Custom(LREventViaTcp10 as LRE; TimerSignal as TS) {
			logic
				state: {
					mutable uint64 _eventCnt = 0ul;
					mutable uint64 _lastKnownEventCnt = 0ul;
					mutable boolean _linearRoadProcessingEnded = false;
					mutable VehicleExpresswayInfoType _vehicleExpresswayInfoTuple = {};
					mutable map<int32, VehicleExpresswayInfoType> _vehicleExpresswayInfoCache = {};
					mutable LinearRoadEventType _mostRecentlyReceivedEvent = {};
					mutable int32 _emptyEventsReceivedErrorCnt = 0;
					mutable int32 _unconfiguredExpresswayType0AndType3EventsReceived = 0;
					mutable int32 _unconfiguredExpresswayType2EventsReceived = 0;
				}
				
				onTuple LRE: {
					// The LR Data feeder seems to send a completely empty event record with all the
					// attributes set to a value of 0. This happens when the data feeder reaches the
					// very end of the data file. We will catch that event with an invalid vehicleId
					// of 0 and discard it.
					if (LRE.vehicleId <= 0) {
						appTrc(Trace.debug, "_X_EEEEEEEEEEEEEEEEEEEEE (Inside the event splitter operator) " +
							"Received a tuple with an empty vehicle id right after the event " + 
							(rstring)_eventCnt + " and discarded it." +
							" Incoming Event=" + (rstring)LRE);		
						_emptyEventsReceivedErrorCnt++;				
						return;
					}

					// For the 15 xways and 25 xways, we will be using the 50 xways data set since 
					// we didn't generate separate data set files for 15x and 25x. In that case, we will
					// have to discard the LR events that are targetted for an unconfigured expressway.
					// That is what is being done in the next two if blocks.
					//					
					// If the incoming LR event is not for one of the configured expressways, then we can ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) && 
						(LRE.eventType == $POSTION_REPORT_EVENT || LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) && 
						(LRE.expressWayNumber >= <%=$totalNumberOfExpressways%>)) {
						// This LR event is for an expressway that is higher than
						// what is configured in this composite via a PERL variable.
						_unconfiguredExpresswayType0AndType3EventsReceived++;
						return;
					}
					
					// If the incoming Account Balance LR event has a vehicle id that has not been seen in
					// any of the configured expressways, then we will ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) &&
						(LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) &&
						((LRE.vehicleId in _vehicleExpresswayInfoCache) == false)) {
						_unconfiguredExpresswayType2EventsReceived++;
						return;	
					}
					
					// As soon as we receive an LR event, we must record the event reception time.
					// This will be used later to calculate the time we are going to take in processing this event.
					LRE.eventRxTimestamp = getSeconds(getTimestamp());
					_eventCnt++;
					// Let us keep a copy of the most recently received event in a state variable.
					// This will be used to print the very last tuple that came from the data feeder when
					// the entire Linear Road processing is completed.
					assignFrom(_mostRecentlyReceivedEvent, LRE);
					
					// Always print the very first event.
					// After that, print only once for every 500K events.
					if ((_eventCnt == 1ul) || ((_eventCnt % 500000ul) == 0ul))  {
						if (_eventCnt == 1ul) {
							appTrc(Trace.error, "******* START OF LINEAR ROAD PROCESSING (main application entry point) *******");
						}
					
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)LRE);
					}

					// Now, route it to the appropriate event processor based on the event type.
					if (LRE.eventType == $POSTION_REPORT_EVENT) {
						// Store in which expressway a given vehicle is traveling now.
						// This is needed for routing the type 2 account balance queries to the 
						// correct type 0 event processor's parallel channel. See more comments in the
						// following "else if" block.						
						_vehicleExpresswayInfoTuple.expressWayNumber = LRE.expressWayNumber;
						_vehicleExpresswayInfoTuple.directionIndicator = LRE.directionIndicator;
						insertM(_vehicleExpresswayInfoCache, LRE.vehicleId, _vehicleExpresswayInfoTuple);
						submit(LRE, PositionReport_10);
					} else if (LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) {
						// Please note that any account balance query will have to be routed via
						// the position report event processor in order to maintain the tuple arrival order.
						// That will allow the position report event processor to be ready with the
						// balance for a given vehicle by the time the account balance (type 2) query
						// hits this Streams application. So, send a type 2 event to the type 0 event
						// processor which in turn will forward that type 2 event to the correct
						// account balance event processor below.
						// If we don't route a type 2 event via the type 0 event processor, then it will
						// cause cache misses in the DPS store by getting ahead of a more recent type 0
						// event that is still waiting inside the input queue of the very busy position
						// report event processor. Hence, let us make this type 2 event sojourn inside
						// the PositionReportEventProcessor for a little while before it is forwarded from
						// there to its own Type 2 event processor.
						//
						// This is going to be tricky since account balance queries are done only by
						// sending us the vehicle id. So, we have to simply know in which expressway and
						// direction that vehicle was seen last and route this type 2 event to a specific
						// instance of the position report event processor PE. That is why, we are maintaining
						// a separate map to find out a given vehicle's last known expressway and direction.
						//
						if (LRE.vehicleId in _vehicleExpresswayInfoCache) {
							// Assign the last known expressway and direction indicator for this vehicle.
							// With these values, it will land in the correct type 0 event processor where this
							// vehicle is already getting processed. We want this type 2 event to line up
							// behind those type 0 events belonging to a given vehicle.
							LRE.expressWayNumber =  _vehicleExpresswayInfoCache[LRE.vehicleId].expressWayNumber;
							LRE.directionIndicator = _vehicleExpresswayInfoCache[LRE.vehicleId].directionIndicator;
						} else {
							// This vehicle has not yet sent its very first position report to us.
							// That means, a type 2 event is coming much before the very first type 0 event for
							// that vehicle is sent to our application. (This can be double-checked in the data set.)
							// In such cases, we will simply send it to the very first position report event processor that
							// is handling expressway 0 and direction indicatior 0 (eastbound) to get forwarded from
							// there to the type 2 event processor.
							LRE.expressWayNumber =  90;
							LRE.directionIndicator = 0;
						}

						// It will now get shuttled to a particular channel of the PositionReportEventProcessor's parallel
						// region and then get forwarded from there to the type 2 event processor thereby putting it
						// in the right spot to obtain and respond with the most recently updated account balance for
						// a given vehicle. 
						submit(LRE, PositionReport_10);
					} else if (LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) {
						// LR specification says, we should respond to a type 3 event only for those days that were in the past.
						// If this type 3 event asks about the daily expenditure for today i.e. dayInThePast = 0,
						// we can simply ignore it by not sending any response back.
						if (LRE.dayInThePast > 0) {
							submit(LRE, DailyExpenditure10);
						} else {
							// Ignore a type 3 event that is asking about the daily expenditure for the current day.
							appTrc(Trace.debug, "_X_DDDDDDDDDDDDDD (Inside the event splitter operator) " +
								"Ignoring the type 3 event asking for daily expenditure with dayInThePast set to 0." +
								" Incoming Type 3 Event=" + (rstring)LRE);
						}
					}
				}
				
				onTuple TS: {
					// Let us see if the entire processing had ended so that we can print a closing line in the log file.
					if ((_eventCnt <= 0ul) || (_linearRoadProcessingEnded == true)) {
						// If the application run has not even started, nothing to do here and simply return back.
						// Do the same thing when the linear road processing had already ended.
						return;
					}
					
					if (_lastKnownEventCnt < _eventCnt) {
						// Linear road processing is actively in progress. Let us keep it going.
						_lastKnownEventCnt = _eventCnt;
					} else if (_lastKnownEventCnt == _eventCnt) {
						// Event count has not changed since we last visited here.
						// That means, Linear Road processing must have ended.
						// Let us print the final message in the PE log.
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)_mostRecentlyReceivedEvent);
						appTrc(Trace.error, "Empty event tuple error count = " + (rstring)_emptyEventsReceivedErrorCnt);
						appTrc(Trace.error, "Type 0 and 3 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType0AndType3EventsReceived);
						appTrc(Trace.error, "Type 2 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType2EventsReceived);
						appTrc(Trace.error, "******* END OF LINEAR ROAD PROCESSING (main application entry point) *******");
						_linearRoadProcessingEnded = true;
					} 
				}
				
			config
				threadedPort: queue(LRE, Sys.Wait);
				// Fuse it with the LR-DataReceiver partition.
				placement: host(lrPool[4]), partitionColocation("LR-DataReceiver10");
		}
		
		// We will split the type 0 position report events to go to the individual instances of
		// the type 0 event processor operator based on a unique combination of
		// "expressWayNumber + directionIndicator".
		<% my $cnt = 0; %>
		(
		 <% for ($cnt = 181; $cnt <= 200; $cnt++) { %>
		 stream<LinearRoadEventType> PositionReport<%=$cnt%><% if ($cnt < 200) { %>; <% }} %>
		) = Split(PositionReport_10 as PR) {				
			param
				file: getApplicationDir() +  "/etc/routing-map-for-type0-events-splitter10.txt";
				key: (rstring)PR.expressWayNumber + "_" + (rstring)PR.directionIndicator;

			config
				// Fuse it with the LR-DataReceiver partition.
				placement: partitionColocation("LR-DataReceiver10");
		} 
// ==================================================================
		// Bank 11
		// Linear Road scenario has 4 event types: 
		// 0) Position reports (real time a.k.a continuous query)
		// 2) Account balance (historical query)
		// 3) Daily expenditure report (historical query)
		// 4) Travel time estimation (historical query)
		//
		// In this application, we will only handle the first three event types and skip the fourth one.
		// Split the incoming data according to the event type in order for them to reach the 
		// appropriate downstream operators capable of processing a specific event.
		//
		// Incoming LR events will arrive here either directly from the data feeder (via TCP) or
		// from an asynchronous messaging system (via kafka).
		// 200x version --> Receive and route data for expressways 100 to 109
		(stream<LinearRoadEventType> PositionReport_11; stream<LinearRoadEventType> DailyExpenditure11) =
			Custom(LREventViaTcp11 as LRE; TimerSignal as TS) {
			logic
				state: {
					mutable uint64 _eventCnt = 0ul;
					mutable uint64 _lastKnownEventCnt = 0ul;
					mutable boolean _linearRoadProcessingEnded = false;
					mutable VehicleExpresswayInfoType _vehicleExpresswayInfoTuple = {};
					mutable map<int32, VehicleExpresswayInfoType> _vehicleExpresswayInfoCache = {};
					mutable LinearRoadEventType _mostRecentlyReceivedEvent = {};
					mutable int32 _emptyEventsReceivedErrorCnt = 0;
					mutable int32 _unconfiguredExpresswayType0AndType3EventsReceived = 0;
					mutable int32 _unconfiguredExpresswayType2EventsReceived = 0;
				}
				
				onTuple LRE: {
					// The LR Data feeder seems to send a completely empty event record with all the
					// attributes set to a value of 0. This happens when the data feeder reaches the
					// very end of the data file. We will catch that event with an invalid vehicleId
					// of 0 and discard it.
					if (LRE.vehicleId <= 0) {
						appTrc(Trace.debug, "_X_EEEEEEEEEEEEEEEEEEEEE (Inside the event splitter operator) " +
							"Received a tuple with an empty vehicle id right after the event " + 
							(rstring)_eventCnt + " and discarded it." +
							" Incoming Event=" + (rstring)LRE);		
						_emptyEventsReceivedErrorCnt++;				
						return;
					}

					// For the 15 xways and 25 xways, we will be using the 50 xways data set since 
					// we didn't generate separate data set files for 15x and 25x. In that case, we will
					// have to discard the LR events that are targetted for an unconfigured expressway.
					// That is what is being done in the next two if blocks.
					//					
					// If the incoming LR event is not for one of the configured expressways, then we can ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) && 
						(LRE.eventType == $POSTION_REPORT_EVENT || LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) && 
						(LRE.expressWayNumber >= <%=$totalNumberOfExpressways%>)) {
						// This LR event is for an expressway that is higher than
						// what is configured in this composite via a PERL variable.
						_unconfiguredExpresswayType0AndType3EventsReceived++;
						return;
					}
					
					// If the incoming Account Balance LR event has a vehicle id that has not been seen in
					// any of the configured expressways, then we will ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) &&
						(LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) &&
						((LRE.vehicleId in _vehicleExpresswayInfoCache) == false)) {
						_unconfiguredExpresswayType2EventsReceived++;
						return;	
					}
					
					// As soon as we receive an LR event, we must record the event reception time.
					// This will be used later to calculate the time we are going to take in processing this event.
					LRE.eventRxTimestamp = getSeconds(getTimestamp());
					_eventCnt++;
					// Let us keep a copy of the most recently received event in a state variable.
					// This will be used to print the very last tuple that came from the data feeder when
					// the entire Linear Road processing is completed.
					assignFrom(_mostRecentlyReceivedEvent, LRE);
					
					// Always print the very first event.
					// After that, print only once for every 500K events.
					if ((_eventCnt == 1ul) || ((_eventCnt % 500000ul) == 0ul))  {
						if (_eventCnt == 1ul) {
							appTrc(Trace.error, "******* START OF LINEAR ROAD PROCESSING (main application entry point) *******");
						}
					
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)LRE);
					}

					// Now, route it to the appropriate event processor based on the event type.
					if (LRE.eventType == $POSTION_REPORT_EVENT) {
						// Store in which expressway a given vehicle is traveling now.
						// This is needed for routing the type 2 account balance queries to the 
						// correct type 0 event processor's parallel channel. See more comments in the
						// following "else if" block.						
						_vehicleExpresswayInfoTuple.expressWayNumber = LRE.expressWayNumber;
						_vehicleExpresswayInfoTuple.directionIndicator = LRE.directionIndicator;
						insertM(_vehicleExpresswayInfoCache, LRE.vehicleId, _vehicleExpresswayInfoTuple);
						submit(LRE, PositionReport_11);
					} else if (LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) {
						// Please note that any account balance query will have to be routed via
						// the position report event processor in order to maintain the tuple arrival order.
						// That will allow the position report event processor to be ready with the
						// balance for a given vehicle by the time the account balance (type 2) query
						// hits this Streams application. So, send a type 2 event to the type 0 event
						// processor which in turn will forward that type 2 event to the correct
						// account balance event processor below.
						// If we don't route a type 2 event via the type 0 event processor, then it will
						// cause cache misses in the DPS store by getting ahead of a more recent type 0
						// event that is still waiting inside the input queue of the very busy position
						// report event processor. Hence, let us make this type 2 event sojourn inside
						// the PositionReportEventProcessor for a little while before it is forwarded from
						// there to its own Type 2 event processor.
						//
						// This is going to be tricky since account balance queries are done only by
						// sending us the vehicle id. So, we have to simply know in which expressway and
						// direction that vehicle was seen last and route this type 2 event to a specific
						// instance of the position report event processor PE. That is why, we are maintaining
						// a separate map to find out a given vehicle's last known expressway and direction.
						//
						if (LRE.vehicleId in _vehicleExpresswayInfoCache) {
							// Assign the last known expressway and direction indicator for this vehicle.
							// With these values, it will land in the correct type 0 event processor where this
							// vehicle is already getting processed. We want this type 2 event to line up
							// behind those type 0 events belonging to a given vehicle.
							LRE.expressWayNumber =  _vehicleExpresswayInfoCache[LRE.vehicleId].expressWayNumber;
							LRE.directionIndicator = _vehicleExpresswayInfoCache[LRE.vehicleId].directionIndicator;
						} else {
							// This vehicle has not yet sent its very first position report to us.
							// That means, a type 2 event is coming much before the very first type 0 event for
							// that vehicle is sent to our application. (This can be double-checked in the data set.)
							// In such cases, we will simply send it to the very first position report event processor that
							// is handling expressway 0 and direction indicatior 0 (eastbound) to get forwarded from
							// there to the type 2 event processor.
							LRE.expressWayNumber =  100;
							LRE.directionIndicator = 0;
						}

						// It will now get shuttled to a particular channel of the PositionReportEventProcessor's parallel
						// region and then get forwarded from there to the type 2 event processor thereby putting it
						// in the right spot to obtain and respond with the most recently updated account balance for
						// a given vehicle. 
						submit(LRE, PositionReport_11);
					} else if (LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) {
						// LR specification says, we should respond to a type 3 event only for those days that were in the past.
						// If this type 3 event asks about the daily expenditure for today i.e. dayInThePast = 0,
						// we can simply ignore it by not sending any response back.
						if (LRE.dayInThePast > 0) {
							submit(LRE, DailyExpenditure11);
						} else {
							// Ignore a type 3 event that is asking about the daily expenditure for the current day.
							appTrc(Trace.debug, "_X_DDDDDDDDDDDDDD (Inside the event splitter operator) " +
								"Ignoring the type 3 event asking for daily expenditure with dayInThePast set to 0." +
								" Incoming Type 3 Event=" + (rstring)LRE);
						}
					}
				}
				
				onTuple TS: {
					// Let us see if the entire processing had ended so that we can print a closing line in the log file.
					if ((_eventCnt <= 0ul) || (_linearRoadProcessingEnded == true)) {
						// If the application run has not even started, nothing to do here and simply return back.
						// Do the same thing when the linear road processing had already ended.
						return;
					}
					
					if (_lastKnownEventCnt < _eventCnt) {
						// Linear road processing is actively in progress. Let us keep it going.
						_lastKnownEventCnt = _eventCnt;
					} else if (_lastKnownEventCnt == _eventCnt) {
						// Event count has not changed since we last visited here.
						// That means, Linear Road processing must have ended.
						// Let us print the final message in the PE log.
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)_mostRecentlyReceivedEvent);
						appTrc(Trace.error, "Empty event tuple error count = " + (rstring)_emptyEventsReceivedErrorCnt);
						appTrc(Trace.error, "Type 0 and 3 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType0AndType3EventsReceived);
						appTrc(Trace.error, "Type 2 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType2EventsReceived);
						appTrc(Trace.error, "******* END OF LINEAR ROAD PROCESSING (main application entry point) *******");
						_linearRoadProcessingEnded = true;
					} 
				}
				
			config
				threadedPort: queue(LRE, Sys.Wait);
				// Fuse it with the LR-DataReceiver partition.
				placement: host(lrPool[0]), partitionColocation("LR-DataReceiver11");
		}
		
		// We will split the type 0 position report events to go to the individual instances of
		// the type 0 event processor operator based on a unique combination of
		// "expressWayNumber + directionIndicator".
		<% my $cnt = 0; %>
		(
		 <% for ($cnt = 201; $cnt <= 220; $cnt++) { %>
		 stream<LinearRoadEventType> PositionReport<%=$cnt%><% if ($cnt < 220) { %>; <% }} %>
		) = Split(PositionReport_11 as PR) {				
			param
				file: getApplicationDir() +  "/etc/routing-map-for-type0-events-splitter11.txt";
				key: (rstring)PR.expressWayNumber + "_" + (rstring)PR.directionIndicator;

			config
				// Fuse it with the LR-DataReceiver partition.
				placement: partitionColocation("LR-DataReceiver11");
		} 
// ==================================================================
		// Bank 12
		// Linear Road scenario has 4 event types: 
		// 0) Position reports (real time a.k.a continuous query)
		// 2) Account balance (historical query)
		// 3) Daily expenditure report (historical query)
		// 4) Travel time estimation (historical query)
		//
		// In this application, we will only handle the first three event types and skip the fourth one.
		// Split the incoming data according to the event type in order for them to reach the 
		// appropriate downstream operators capable of processing a specific event.
		//
		// Incoming LR events will arrive here either directly from the data feeder (via TCP) or
		// from an asynchronous messaging system (via kafka).
		// 200x version --> Receive and route data for expressways 110 to 119
		(stream<LinearRoadEventType> PositionReport_12; stream<LinearRoadEventType> DailyExpenditure12) =
			Custom(LREventViaTcp12 as LRE; TimerSignal as TS) {
			logic
				state: {
					mutable uint64 _eventCnt = 0ul;
					mutable uint64 _lastKnownEventCnt = 0ul;
					mutable boolean _linearRoadProcessingEnded = false;
					mutable VehicleExpresswayInfoType _vehicleExpresswayInfoTuple = {};
					mutable map<int32, VehicleExpresswayInfoType> _vehicleExpresswayInfoCache = {};
					mutable LinearRoadEventType _mostRecentlyReceivedEvent = {};
					mutable int32 _emptyEventsReceivedErrorCnt = 0;
					mutable int32 _unconfiguredExpresswayType0AndType3EventsReceived = 0;
					mutable int32 _unconfiguredExpresswayType2EventsReceived = 0;
				}
				
				onTuple LRE: {
					// The LR Data feeder seems to send a completely empty event record with all the
					// attributes set to a value of 0. This happens when the data feeder reaches the
					// very end of the data file. We will catch that event with an invalid vehicleId
					// of 0 and discard it.
					if (LRE.vehicleId <= 0) {
						appTrc(Trace.debug, "_X_EEEEEEEEEEEEEEEEEEEEE (Inside the event splitter operator) " +
							"Received a tuple with an empty vehicle id right after the event " + 
							(rstring)_eventCnt + " and discarded it." +
							" Incoming Event=" + (rstring)LRE);		
						_emptyEventsReceivedErrorCnt++;				
						return;
					}

					// For the 15 xways and 25 xways, we will be using the 50 xways data set since 
					// we didn't generate separate data set files for 15x and 25x. In that case, we will
					// have to discard the LR events that are targetted for an unconfigured expressway.
					// That is what is being done in the next two if blocks.
					//					
					// If the incoming LR event is not for one of the configured expressways, then we can ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) && 
						(LRE.eventType == $POSTION_REPORT_EVENT || LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) && 
						(LRE.expressWayNumber >= <%=$totalNumberOfExpressways%>)) {
						// This LR event is for an expressway that is higher than
						// what is configured in this composite via a PERL variable.
						_unconfiguredExpresswayType0AndType3EventsReceived++;
						return;
					}
					
					// If the incoming Account Balance LR event has a vehicle id that has not been seen in
					// any of the configured expressways, then we will ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) &&
						(LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) &&
						((LRE.vehicleId in _vehicleExpresswayInfoCache) == false)) {
						_unconfiguredExpresswayType2EventsReceived++;
						return;	
					}
					
					// As soon as we receive an LR event, we must record the event reception time.
					// This will be used later to calculate the time we are going to take in processing this event.
					LRE.eventRxTimestamp = getSeconds(getTimestamp());
					_eventCnt++;
					// Let us keep a copy of the most recently received event in a state variable.
					// This will be used to print the very last tuple that came from the data feeder when
					// the entire Linear Road processing is completed.
					assignFrom(_mostRecentlyReceivedEvent, LRE);
					
					// Always print the very first event.
					// After that, print only once for every 500K events.
					if ((_eventCnt == 1ul) || ((_eventCnt % 500000ul) == 0ul))  {
						if (_eventCnt == 1ul) {
							appTrc(Trace.error, "******* START OF LINEAR ROAD PROCESSING (main application entry point) *******");
						}
					
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)LRE);
					}

					// Now, route it to the appropriate event processor based on the event type.
					if (LRE.eventType == $POSTION_REPORT_EVENT) {
						// Store in which expressway a given vehicle is traveling now.
						// This is needed for routing the type 2 account balance queries to the 
						// correct type 0 event processor's parallel channel. See more comments in the
						// following "else if" block.						
						_vehicleExpresswayInfoTuple.expressWayNumber = LRE.expressWayNumber;
						_vehicleExpresswayInfoTuple.directionIndicator = LRE.directionIndicator;
						insertM(_vehicleExpresswayInfoCache, LRE.vehicleId, _vehicleExpresswayInfoTuple);
						submit(LRE, PositionReport_12);
					} else if (LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) {
						// Please note that any account balance query will have to be routed via
						// the position report event processor in order to maintain the tuple arrival order.
						// That will allow the position report event processor to be ready with the
						// balance for a given vehicle by the time the account balance (type 2) query
						// hits this Streams application. So, send a type 2 event to the type 0 event
						// processor which in turn will forward that type 2 event to the correct
						// account balance event processor below.
						// If we don't route a type 2 event via the type 0 event processor, then it will
						// cause cache misses in the DPS store by getting ahead of a more recent type 0
						// event that is still waiting inside the input queue of the very busy position
						// report event processor. Hence, let us make this type 2 event sojourn inside
						// the PositionReportEventProcessor for a little while before it is forwarded from
						// there to its own Type 2 event processor.
						//
						// This is going to be tricky since account balance queries are done only by
						// sending us the vehicle id. So, we have to simply know in which expressway and
						// direction that vehicle was seen last and route this type 2 event to a specific
						// instance of the position report event processor PE. That is why, we are maintaining
						// a separate map to find out a given vehicle's last known expressway and direction.
						//
						if (LRE.vehicleId in _vehicleExpresswayInfoCache) {
							// Assign the last known expressway and direction indicator for this vehicle.
							// With these values, it will land in the correct type 0 event processor where this
							// vehicle is already getting processed. We want this type 2 event to line up
							// behind those type 0 events belonging to a given vehicle.
							LRE.expressWayNumber =  _vehicleExpresswayInfoCache[LRE.vehicleId].expressWayNumber;
							LRE.directionIndicator = _vehicleExpresswayInfoCache[LRE.vehicleId].directionIndicator;
						} else {
							// This vehicle has not yet sent its very first position report to us.
							// That means, a type 2 event is coming much before the very first type 0 event for
							// that vehicle is sent to our application. (This can be double-checked in the data set.)
							// In such cases, we will simply send it to the very first position report event processor that
							// is handling expressway 0 and direction indicatior 0 (eastbound) to get forwarded from
							// there to the type 2 event processor.
							LRE.expressWayNumber =  110;
							LRE.directionIndicator = 0;
						}

						// It will now get shuttled to a particular channel of the PositionReportEventProcessor's parallel
						// region and then get forwarded from there to the type 2 event processor thereby putting it
						// in the right spot to obtain and respond with the most recently updated account balance for
						// a given vehicle. 
						submit(LRE, PositionReport_12);
					} else if (LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) {
						// LR specification says, we should respond to a type 3 event only for those days that were in the past.
						// If this type 3 event asks about the daily expenditure for today i.e. dayInThePast = 0,
						// we can simply ignore it by not sending any response back.
						if (LRE.dayInThePast > 0) {
							submit(LRE, DailyExpenditure12);
						} else {
							// Ignore a type 3 event that is asking about the daily expenditure for the current day.
							appTrc(Trace.debug, "_X_DDDDDDDDDDDDDD (Inside the event splitter operator) " +
								"Ignoring the type 3 event asking for daily expenditure with dayInThePast set to 0." +
								" Incoming Type 3 Event=" + (rstring)LRE);
						}
					}
				}
				
				onTuple TS: {
					// Let us see if the entire processing had ended so that we can print a closing line in the log file.
					if ((_eventCnt <= 0ul) || (_linearRoadProcessingEnded == true)) {
						// If the application run has not even started, nothing to do here and simply return back.
						// Do the same thing when the linear road processing had already ended.
						return;
					}
					
					if (_lastKnownEventCnt < _eventCnt) {
						// Linear road processing is actively in progress. Let us keep it going.
						_lastKnownEventCnt = _eventCnt;
					} else if (_lastKnownEventCnt == _eventCnt) {
						// Event count has not changed since we last visited here.
						// That means, Linear Road processing must have ended.
						// Let us print the final message in the PE log.
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)_mostRecentlyReceivedEvent);
						appTrc(Trace.error, "Empty event tuple error count = " + (rstring)_emptyEventsReceivedErrorCnt);
						appTrc(Trace.error, "Type 0 and 3 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType0AndType3EventsReceived);
						appTrc(Trace.error, "Type 2 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType2EventsReceived);
						appTrc(Trace.error, "******* END OF LINEAR ROAD PROCESSING (main application entry point) *******");
						_linearRoadProcessingEnded = true;
					} 
				}
				
			config
				threadedPort: queue(LRE, Sys.Wait);
				// Fuse it with the LR-DataReceiver partition.
				placement: host(lrPool[1]), partitionColocation("LR-DataReceiver12");
		}
		
		// We will split the type 0 position report events to go to the individual instances of
		// the type 0 event processor operator based on a unique combination of
		// "expressWayNumber + directionIndicator".
		<% my $cnt = 0; %>
		(
		 <% for ($cnt = 221; $cnt <= 240; $cnt++) { %>
		 stream<LinearRoadEventType> PositionReport<%=$cnt%><% if ($cnt < 240) { %>; <% }} %>
		) = Split(PositionReport_12 as PR) {				
			param
				file: getApplicationDir() +  "/etc/routing-map-for-type0-events-splitter12.txt";
				key: (rstring)PR.expressWayNumber + "_" + (rstring)PR.directionIndicator;

			config
				// Fuse it with the LR-DataReceiver partition.
				placement: partitionColocation("LR-DataReceiver12");
		} 
// ==================================================================
		// Bank 13
		// Linear Road scenario has 4 event types: 
		// 0) Position reports (real time a.k.a continuous query)
		// 2) Account balance (historical query)
		// 3) Daily expenditure report (historical query)
		// 4) Travel time estimation (historical query)
		//
		// In this application, we will only handle the first three event types and skip the fourth one.
		// Split the incoming data according to the event type in order for them to reach the 
		// appropriate downstream operators capable of processing a specific event.
		//
		// Incoming LR events will arrive here either directly from the data feeder (via TCP) or
		// from an asynchronous messaging system (via kafka).
		// 200x version --> Receive and route data for expressways 120 to 129
		(stream<LinearRoadEventType> PositionReport_13; stream<LinearRoadEventType> DailyExpenditure13) =
			Custom(LREventViaTcp13 as LRE; TimerSignal as TS) {
			logic
				state: {
					mutable uint64 _eventCnt = 0ul;
					mutable uint64 _lastKnownEventCnt = 0ul;
					mutable boolean _linearRoadProcessingEnded = false;
					mutable VehicleExpresswayInfoType _vehicleExpresswayInfoTuple = {};
					mutable map<int32, VehicleExpresswayInfoType> _vehicleExpresswayInfoCache = {};
					mutable LinearRoadEventType _mostRecentlyReceivedEvent = {};
					mutable int32 _emptyEventsReceivedErrorCnt = 0;
					mutable int32 _unconfiguredExpresswayType0AndType3EventsReceived = 0;
					mutable int32 _unconfiguredExpresswayType2EventsReceived = 0;
				}
				
				onTuple LRE: {
					// The LR Data feeder seems to send a completely empty event record with all the
					// attributes set to a value of 0. This happens when the data feeder reaches the
					// very end of the data file. We will catch that event with an invalid vehicleId
					// of 0 and discard it.
					if (LRE.vehicleId <= 0) {
						appTrc(Trace.debug, "_X_EEEEEEEEEEEEEEEEEEEEE (Inside the event splitter operator) " +
							"Received a tuple with an empty vehicle id right after the event " + 
							(rstring)_eventCnt + " and discarded it." +
							" Incoming Event=" + (rstring)LRE);		
						_emptyEventsReceivedErrorCnt++;				
						return;
					}

					// For the 15 xways and 25 xways, we will be using the 50 xways data set since 
					// we didn't generate separate data set files for 15x and 25x. In that case, we will
					// have to discard the LR events that are targetted for an unconfigured expressway.
					// That is what is being done in the next two if blocks.
					//					
					// If the incoming LR event is not for one of the configured expressways, then we can ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) && 
						(LRE.eventType == $POSTION_REPORT_EVENT || LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) && 
						(LRE.expressWayNumber >= <%=$totalNumberOfExpressways%>)) {
						// This LR event is for an expressway that is higher than
						// what is configured in this composite via a PERL variable.
						_unconfiguredExpresswayType0AndType3EventsReceived++;
						return;
					}
					
					// If the incoming Account Balance LR event has a vehicle id that has not been seen in
					// any of the configured expressways, then we will ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) &&
						(LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) &&
						((LRE.vehicleId in _vehicleExpresswayInfoCache) == false)) {
						_unconfiguredExpresswayType2EventsReceived++;
						return;	
					}
					
					// As soon as we receive an LR event, we must record the event reception time.
					// This will be used later to calculate the time we are going to take in processing this event.
					LRE.eventRxTimestamp = getSeconds(getTimestamp());
					_eventCnt++;
					// Let us keep a copy of the most recently received event in a state variable.
					// This will be used to print the very last tuple that came from the data feeder when
					// the entire Linear Road processing is completed.
					assignFrom(_mostRecentlyReceivedEvent, LRE);
					
					// Always print the very first event.
					// After that, print only once for every 500K events.
					if ((_eventCnt == 1ul) || ((_eventCnt % 500000ul) == 0ul))  {
						if (_eventCnt == 1ul) {
							appTrc(Trace.error, "******* START OF LINEAR ROAD PROCESSING (main application entry point) *******");
						}
					
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)LRE);
					}

					// Now, route it to the appropriate event processor based on the event type.
					if (LRE.eventType == $POSTION_REPORT_EVENT) {
						// Store in which expressway a given vehicle is traveling now.
						// This is needed for routing the type 2 account balance queries to the 
						// correct type 0 event processor's parallel channel. See more comments in the
						// following "else if" block.						
						_vehicleExpresswayInfoTuple.expressWayNumber = LRE.expressWayNumber;
						_vehicleExpresswayInfoTuple.directionIndicator = LRE.directionIndicator;
						insertM(_vehicleExpresswayInfoCache, LRE.vehicleId, _vehicleExpresswayInfoTuple);
						submit(LRE, PositionReport_13);
					} else if (LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) {
						// Please note that any account balance query will have to be routed via
						// the position report event processor in order to maintain the tuple arrival order.
						// That will allow the position report event processor to be ready with the
						// balance for a given vehicle by the time the account balance (type 2) query
						// hits this Streams application. So, send a type 2 event to the type 0 event
						// processor which in turn will forward that type 2 event to the correct
						// account balance event processor below.
						// If we don't route a type 2 event via the type 0 event processor, then it will
						// cause cache misses in the DPS store by getting ahead of a more recent type 0
						// event that is still waiting inside the input queue of the very busy position
						// report event processor. Hence, let us make this type 2 event sojourn inside
						// the PositionReportEventProcessor for a little while before it is forwarded from
						// there to its own Type 2 event processor.
						//
						// This is going to be tricky since account balance queries are done only by
						// sending us the vehicle id. So, we have to simply know in which expressway and
						// direction that vehicle was seen last and route this type 2 event to a specific
						// instance of the position report event processor PE. That is why, we are maintaining
						// a separate map to find out a given vehicle's last known expressway and direction.
						//
						if (LRE.vehicleId in _vehicleExpresswayInfoCache) {
							// Assign the last known expressway and direction indicator for this vehicle.
							// With these values, it will land in the correct type 0 event processor where this
							// vehicle is already getting processed. We want this type 2 event to line up
							// behind those type 0 events belonging to a given vehicle.
							LRE.expressWayNumber =  _vehicleExpresswayInfoCache[LRE.vehicleId].expressWayNumber;
							LRE.directionIndicator = _vehicleExpresswayInfoCache[LRE.vehicleId].directionIndicator;
						} else {
							// This vehicle has not yet sent its very first position report to us.
							// That means, a type 2 event is coming much before the very first type 0 event for
							// that vehicle is sent to our application. (This can be double-checked in the data set.)
							// In such cases, we will simply send it to the very first position report event processor that
							// is handling expressway 0 and direction indicatior 0 (eastbound) to get forwarded from
							// there to the type 2 event processor.
							LRE.expressWayNumber =  120;
							LRE.directionIndicator = 0;
						}

						// It will now get shuttled to a particular channel of the PositionReportEventProcessor's parallel
						// region and then get forwarded from there to the type 2 event processor thereby putting it
						// in the right spot to obtain and respond with the most recently updated account balance for
						// a given vehicle. 
						submit(LRE, PositionReport_13);
					} else if (LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) {
						// LR specification says, we should respond to a type 3 event only for those days that were in the past.
						// If this type 3 event asks about the daily expenditure for today i.e. dayInThePast = 0,
						// we can simply ignore it by not sending any response back.
						if (LRE.dayInThePast > 0) {
							submit(LRE, DailyExpenditure13);
						} else {
							// Ignore a type 3 event that is asking about the daily expenditure for the current day.
							appTrc(Trace.debug, "_X_DDDDDDDDDDDDDD (Inside the event splitter operator) " +
								"Ignoring the type 3 event asking for daily expenditure with dayInThePast set to 0." +
								" Incoming Type 3 Event=" + (rstring)LRE);
						}
					}
				}
				
				onTuple TS: {
					// Let us see if the entire processing had ended so that we can print a closing line in the log file.
					if ((_eventCnt <= 0ul) || (_linearRoadProcessingEnded == true)) {
						// If the application run has not even started, nothing to do here and simply return back.
						// Do the same thing when the linear road processing had already ended.
						return;
					}
					
					if (_lastKnownEventCnt < _eventCnt) {
						// Linear road processing is actively in progress. Let us keep it going.
						_lastKnownEventCnt = _eventCnt;
					} else if (_lastKnownEventCnt == _eventCnt) {
						// Event count has not changed since we last visited here.
						// That means, Linear Road processing must have ended.
						// Let us print the final message in the PE log.
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)_mostRecentlyReceivedEvent);
						appTrc(Trace.error, "Empty event tuple error count = " + (rstring)_emptyEventsReceivedErrorCnt);
						appTrc(Trace.error, "Type 0 and 3 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType0AndType3EventsReceived);
						appTrc(Trace.error, "Type 2 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType2EventsReceived);
						appTrc(Trace.error, "******* END OF LINEAR ROAD PROCESSING (main application entry point) *******");
						_linearRoadProcessingEnded = true;
					} 
				}
				
			config
				threadedPort: queue(LRE, Sys.Wait);
				// Fuse it with the LR-DataReceiver partition.
				placement: host(lrPool[3]), partitionColocation("LR-DataReceiver13");
		}
		
		// We will split the type 0 position report events to go to the individual instances of
		// the type 0 event processor operator based on a unique combination of
		// "expressWayNumber + directionIndicator".
		<% my $cnt = 0; %>
		(
		 <% for ($cnt = 241; $cnt <= 260; $cnt++) { %>
		 stream<LinearRoadEventType> PositionReport<%=$cnt%><% if ($cnt < 260) { %>; <% }} %>
		) = Split(PositionReport_13 as PR) {				
			param
				file: getApplicationDir() +  "/etc/routing-map-for-type0-events-splitter13.txt";
				key: (rstring)PR.expressWayNumber + "_" + (rstring)PR.directionIndicator;

			config
				// Fuse it with the LR-DataReceiver partition.
				placement: partitionColocation("LR-DataReceiver13");
		} 
// ==================================================================
		// Bank 14
		// Linear Road scenario has 4 event types: 
		// 0) Position reports (real time a.k.a continuous query)
		// 2) Account balance (historical query)
		// 3) Daily expenditure report (historical query)
		// 4) Travel time estimation (historical query)
		//
		// In this application, we will only handle the first three event types and skip the fourth one.
		// Split the incoming data according to the event type in order for them to reach the 
		// appropriate downstream operators capable of processing a specific event.
		//
		// Incoming LR events will arrive here either directly from the data feeder (via TCP) or
		// from an asynchronous messaging system (via kafka).
		// 200x version --> Receive and route data for expressways 130 to 139
		(stream<LinearRoadEventType> PositionReport_14; stream<LinearRoadEventType> DailyExpenditure14) =
			Custom(LREventViaTcp14 as LRE; TimerSignal as TS) {
			logic
				state: {
					mutable uint64 _eventCnt = 0ul;
					mutable uint64 _lastKnownEventCnt = 0ul;
					mutable boolean _linearRoadProcessingEnded = false;
					mutable VehicleExpresswayInfoType _vehicleExpresswayInfoTuple = {};
					mutable map<int32, VehicleExpresswayInfoType> _vehicleExpresswayInfoCache = {};
					mutable LinearRoadEventType _mostRecentlyReceivedEvent = {};
					mutable int32 _emptyEventsReceivedErrorCnt = 0;
					mutable int32 _unconfiguredExpresswayType0AndType3EventsReceived = 0;
					mutable int32 _unconfiguredExpresswayType2EventsReceived = 0;
				}
				
				onTuple LRE: {
					// The LR Data feeder seems to send a completely empty event record with all the
					// attributes set to a value of 0. This happens when the data feeder reaches the
					// very end of the data file. We will catch that event with an invalid vehicleId
					// of 0 and discard it.
					if (LRE.vehicleId <= 0) {
						appTrc(Trace.debug, "_X_EEEEEEEEEEEEEEEEEEEEE (Inside the event splitter operator) " +
							"Received a tuple with an empty vehicle id right after the event " + 
							(rstring)_eventCnt + " and discarded it." +
							" Incoming Event=" + (rstring)LRE);		
						_emptyEventsReceivedErrorCnt++;				
						return;
					}

					// For the 15 xways and 25 xways, we will be using the 50 xways data set since 
					// we didn't generate separate data set files for 15x and 25x. In that case, we will
					// have to discard the LR events that are targetted for an unconfigured expressway.
					// That is what is being done in the next two if blocks.
					//					
					// If the incoming LR event is not for one of the configured expressways, then we can ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) && 
						(LRE.eventType == $POSTION_REPORT_EVENT || LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) && 
						(LRE.expressWayNumber >= <%=$totalNumberOfExpressways%>)) {
						// This LR event is for an expressway that is higher than
						// what is configured in this composite via a PERL variable.
						_unconfiguredExpresswayType0AndType3EventsReceived++;
						return;
					}
					
					// If the incoming Account Balance LR event has a vehicle id that has not been seen in
					// any of the configured expressways, then we will ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) &&
						(LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) &&
						((LRE.vehicleId in _vehicleExpresswayInfoCache) == false)) {
						_unconfiguredExpresswayType2EventsReceived++;
						return;	
					}
					
					// As soon as we receive an LR event, we must record the event reception time.
					// This will be used later to calculate the time we are going to take in processing this event.
					LRE.eventRxTimestamp = getSeconds(getTimestamp());
					_eventCnt++;
					// Let us keep a copy of the most recently received event in a state variable.
					// This will be used to print the very last tuple that came from the data feeder when
					// the entire Linear Road processing is completed.
					assignFrom(_mostRecentlyReceivedEvent, LRE);
					
					// Always print the very first event.
					// After that, print only once for every 500K events.
					if ((_eventCnt == 1ul) || ((_eventCnt % 500000ul) == 0ul))  {
						if (_eventCnt == 1ul) {
							appTrc(Trace.error, "******* START OF LINEAR ROAD PROCESSING (main application entry point) *******");
						}
					
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)LRE);
					}

					// Now, route it to the appropriate event processor based on the event type.
					if (LRE.eventType == $POSTION_REPORT_EVENT) {
						// Store in which expressway a given vehicle is traveling now.
						// This is needed for routing the type 2 account balance queries to the 
						// correct type 0 event processor's parallel channel. See more comments in the
						// following "else if" block.						
						_vehicleExpresswayInfoTuple.expressWayNumber = LRE.expressWayNumber;
						_vehicleExpresswayInfoTuple.directionIndicator = LRE.directionIndicator;
						insertM(_vehicleExpresswayInfoCache, LRE.vehicleId, _vehicleExpresswayInfoTuple);
						submit(LRE, PositionReport_14);
					} else if (LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) {
						// Please note that any account balance query will have to be routed via
						// the position report event processor in order to maintain the tuple arrival order.
						// That will allow the position report event processor to be ready with the
						// balance for a given vehicle by the time the account balance (type 2) query
						// hits this Streams application. So, send a type 2 event to the type 0 event
						// processor which in turn will forward that type 2 event to the correct
						// account balance event processor below.
						// If we don't route a type 2 event via the type 0 event processor, then it will
						// cause cache misses in the DPS store by getting ahead of a more recent type 0
						// event that is still waiting inside the input queue of the very busy position
						// report event processor. Hence, let us make this type 2 event sojourn inside
						// the PositionReportEventProcessor for a little while before it is forwarded from
						// there to its own Type 2 event processor.
						//
						// This is going to be tricky since account balance queries are done only by
						// sending us the vehicle id. So, we have to simply know in which expressway and
						// direction that vehicle was seen last and route this type 2 event to a specific
						// instance of the position report event processor PE. That is why, we are maintaining
						// a separate map to find out a given vehicle's last known expressway and direction.
						//
						if (LRE.vehicleId in _vehicleExpresswayInfoCache) {
							// Assign the last known expressway and direction indicator for this vehicle.
							// With these values, it will land in the correct type 0 event processor where this
							// vehicle is already getting processed. We want this type 2 event to line up
							// behind those type 0 events belonging to a given vehicle.
							LRE.expressWayNumber =  _vehicleExpresswayInfoCache[LRE.vehicleId].expressWayNumber;
							LRE.directionIndicator = _vehicleExpresswayInfoCache[LRE.vehicleId].directionIndicator;
						} else {
							// This vehicle has not yet sent its very first position report to us.
							// That means, a type 2 event is coming much before the very first type 0 event for
							// that vehicle is sent to our application. (This can be double-checked in the data set.)
							// In such cases, we will simply send it to the very first position report event processor that
							// is handling expressway 0 and direction indicatior 0 (eastbound) to get forwarded from
							// there to the type 2 event processor.
							LRE.expressWayNumber =  130;
							LRE.directionIndicator = 0;
						}

						// It will now get shuttled to a particular channel of the PositionReportEventProcessor's parallel
						// region and then get forwarded from there to the type 2 event processor thereby putting it
						// in the right spot to obtain and respond with the most recently updated account balance for
						// a given vehicle. 
						submit(LRE, PositionReport_14);
					} else if (LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) {
						// LR specification says, we should respond to a type 3 event only for those days that were in the past.
						// If this type 3 event asks about the daily expenditure for today i.e. dayInThePast = 0,
						// we can simply ignore it by not sending any response back.
						if (LRE.dayInThePast > 0) {
							submit(LRE, DailyExpenditure14);
						} else {
							// Ignore a type 3 event that is asking about the daily expenditure for the current day.
							appTrc(Trace.debug, "_X_DDDDDDDDDDDDDD (Inside the event splitter operator) " +
								"Ignoring the type 3 event asking for daily expenditure with dayInThePast set to 0." +
								" Incoming Type 3 Event=" + (rstring)LRE);
						}
					}
				}
				
				onTuple TS: {
					// Let us see if the entire processing had ended so that we can print a closing line in the log file.
					if ((_eventCnt <= 0ul) || (_linearRoadProcessingEnded == true)) {
						// If the application run has not even started, nothing to do here and simply return back.
						// Do the same thing when the linear road processing had already ended.
						return;
					}
					
					if (_lastKnownEventCnt < _eventCnt) {
						// Linear road processing is actively in progress. Let us keep it going.
						_lastKnownEventCnt = _eventCnt;
					} else if (_lastKnownEventCnt == _eventCnt) {
						// Event count has not changed since we last visited here.
						// That means, Linear Road processing must have ended.
						// Let us print the final message in the PE log.
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)_mostRecentlyReceivedEvent);
						appTrc(Trace.error, "Empty event tuple error count = " + (rstring)_emptyEventsReceivedErrorCnt);
						appTrc(Trace.error, "Type 0 and 3 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType0AndType3EventsReceived);
						appTrc(Trace.error, "Type 2 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType2EventsReceived);
						appTrc(Trace.error, "******* END OF LINEAR ROAD PROCESSING (main application entry point) *******");
						_linearRoadProcessingEnded = true;
					} 
				}
				
			config
				threadedPort: queue(LRE, Sys.Wait);
				// Fuse it with the LR-DataReceiver partition.
				placement: host(lrPool[3]), partitionColocation("LR-DataReceiver14");
		}
		
		// We will split the type 0 position report events to go to the individual instances of
		// the type 0 event processor operator based on a unique combination of
		// "expressWayNumber + directionIndicator".
		<% my $cnt = 0; %>
		(
		 <% for ($cnt = 261; $cnt <= 280; $cnt++) { %>
		 stream<LinearRoadEventType> PositionReport<%=$cnt%><% if ($cnt < 280) { %>; <% }} %>
		) = Split(PositionReport_14 as PR) {				
			param
				file: getApplicationDir() +  "/etc/routing-map-for-type0-events-splitter14.txt";
				key: (rstring)PR.expressWayNumber + "_" + (rstring)PR.directionIndicator;

			config
				// Fuse it with the LR-DataReceiver partition.
				placement: partitionColocation("LR-DataReceiver14");
		} 
// ==================================================================
		// Bank 15
		// Linear Road scenario has 4 event types: 
		// 0) Position reports (real time a.k.a continuous query)
		// 2) Account balance (historical query)
		// 3) Daily expenditure report (historical query)
		// 4) Travel time estimation (historical query)
		//
		// In this application, we will only handle the first three event types and skip the fourth one.
		// Split the incoming data according to the event type in order for them to reach the 
		// appropriate downstream operators capable of processing a specific event.
		//
		// Incoming LR events will arrive here either directly from the data feeder (via TCP) or
		// from an asynchronous messaging system (via kafka).
		// 200x version --> Receive and route data for expressways 140 to 149
		(stream<LinearRoadEventType> PositionReport_15; stream<LinearRoadEventType> DailyExpenditure15) =
			Custom(LREventViaTcp15 as LRE; TimerSignal as TS) {
			logic
				state: {
					mutable uint64 _eventCnt = 0ul;
					mutable uint64 _lastKnownEventCnt = 0ul;
					mutable boolean _linearRoadProcessingEnded = false;
					mutable VehicleExpresswayInfoType _vehicleExpresswayInfoTuple = {};
					mutable map<int32, VehicleExpresswayInfoType> _vehicleExpresswayInfoCache = {};
					mutable LinearRoadEventType _mostRecentlyReceivedEvent = {};
					mutable int32 _emptyEventsReceivedErrorCnt = 0;
					mutable int32 _unconfiguredExpresswayType0AndType3EventsReceived = 0;
					mutable int32 _unconfiguredExpresswayType2EventsReceived = 0;
				}
				
				onTuple LRE: {
					// The LR Data feeder seems to send a completely empty event record with all the
					// attributes set to a value of 0. This happens when the data feeder reaches the
					// very end of the data file. We will catch that event with an invalid vehicleId
					// of 0 and discard it.
					if (LRE.vehicleId <= 0) {
						appTrc(Trace.debug, "_X_EEEEEEEEEEEEEEEEEEEEE (Inside the event splitter operator) " +
							"Received a tuple with an empty vehicle id right after the event " + 
							(rstring)_eventCnt + " and discarded it." +
							" Incoming Event=" + (rstring)LRE);		
						_emptyEventsReceivedErrorCnt++;				
						return;
					}

					// For the 15 xways and 25 xways, we will be using the 50 xways data set since 
					// we didn't generate separate data set files for 15x and 25x. In that case, we will
					// have to discard the LR events that are targetted for an unconfigured expressway.
					// That is what is being done in the next two if blocks.
					//					
					// If the incoming LR event is not for one of the configured expressways, then we can ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) && 
						(LRE.eventType == $POSTION_REPORT_EVENT || LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) && 
						(LRE.expressWayNumber >= <%=$totalNumberOfExpressways%>)) {
						// This LR event is for an expressway that is higher than
						// what is configured in this composite via a PERL variable.
						_unconfiguredExpresswayType0AndType3EventsReceived++;
						return;
					}
					
					// If the incoming Account Balance LR event has a vehicle id that has not been seen in
					// any of the configured expressways, then we will ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) &&
						(LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) &&
						((LRE.vehicleId in _vehicleExpresswayInfoCache) == false)) {
						_unconfiguredExpresswayType2EventsReceived++;
						return;	
					}
					
					// As soon as we receive an LR event, we must record the event reception time.
					// This will be used later to calculate the time we are going to take in processing this event.
					LRE.eventRxTimestamp = getSeconds(getTimestamp());
					_eventCnt++;
					// Let us keep a copy of the most recently received event in a state variable.
					// This will be used to print the very last tuple that came from the data feeder when
					// the entire Linear Road processing is completed.
					assignFrom(_mostRecentlyReceivedEvent, LRE);
					
					// Always print the very first event.
					// After that, print only once for every 500K events.
					if ((_eventCnt == 1ul) || ((_eventCnt % 500000ul) == 0ul))  {
						if (_eventCnt == 1ul) {
							appTrc(Trace.error, "******* START OF LINEAR ROAD PROCESSING (main application entry point) *******");
						}
					
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)LRE);
					}

					// Now, route it to the appropriate event processor based on the event type.
					if (LRE.eventType == $POSTION_REPORT_EVENT) {
						// Store in which expressway a given vehicle is traveling now.
						// This is needed for routing the type 2 account balance queries to the 
						// correct type 0 event processor's parallel channel. See more comments in the
						// following "else if" block.						
						_vehicleExpresswayInfoTuple.expressWayNumber = LRE.expressWayNumber;
						_vehicleExpresswayInfoTuple.directionIndicator = LRE.directionIndicator;
						insertM(_vehicleExpresswayInfoCache, LRE.vehicleId, _vehicleExpresswayInfoTuple);
						submit(LRE, PositionReport_15);
					} else if (LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) {
						// Please note that any account balance query will have to be routed via
						// the position report event processor in order to maintain the tuple arrival order.
						// That will allow the position report event processor to be ready with the
						// balance for a given vehicle by the time the account balance (type 2) query
						// hits this Streams application. So, send a type 2 event to the type 0 event
						// processor which in turn will forward that type 2 event to the correct
						// account balance event processor below.
						// If we don't route a type 2 event via the type 0 event processor, then it will
						// cause cache misses in the DPS store by getting ahead of a more recent type 0
						// event that is still waiting inside the input queue of the very busy position
						// report event processor. Hence, let us make this type 2 event sojourn inside
						// the PositionReportEventProcessor for a little while before it is forwarded from
						// there to its own Type 2 event processor.
						//
						// This is going to be tricky since account balance queries are done only by
						// sending us the vehicle id. So, we have to simply know in which expressway and
						// direction that vehicle was seen last and route this type 2 event to a specific
						// instance of the position report event processor PE. That is why, we are maintaining
						// a separate map to find out a given vehicle's last known expressway and direction.
						//
						if (LRE.vehicleId in _vehicleExpresswayInfoCache) {
							// Assign the last known expressway and direction indicator for this vehicle.
							// With these values, it will land in the correct type 0 event processor where this
							// vehicle is already getting processed. We want this type 2 event to line up
							// behind those type 0 events belonging to a given vehicle.
							LRE.expressWayNumber =  _vehicleExpresswayInfoCache[LRE.vehicleId].expressWayNumber;
							LRE.directionIndicator = _vehicleExpresswayInfoCache[LRE.vehicleId].directionIndicator;
						} else {
							// This vehicle has not yet sent its very first position report to us.
							// That means, a type 2 event is coming much before the very first type 0 event for
							// that vehicle is sent to our application. (This can be double-checked in the data set.)
							// In such cases, we will simply send it to the very first position report event processor that
							// is handling expressway 0 and direction indicatior 0 (eastbound) to get forwarded from
							// there to the type 2 event processor.
							LRE.expressWayNumber =  140;
							LRE.directionIndicator = 0;
						}

						// It will now get shuttled to a particular channel of the PositionReportEventProcessor's parallel
						// region and then get forwarded from there to the type 2 event processor thereby putting it
						// in the right spot to obtain and respond with the most recently updated account balance for
						// a given vehicle. 
						submit(LRE, PositionReport_15);
					} else if (LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) {
						// LR specification says, we should respond to a type 3 event only for those days that were in the past.
						// If this type 3 event asks about the daily expenditure for today i.e. dayInThePast = 0,
						// we can simply ignore it by not sending any response back.
						if (LRE.dayInThePast > 0) {
							submit(LRE, DailyExpenditure15);
						} else {
							// Ignore a type 3 event that is asking about the daily expenditure for the current day.
							appTrc(Trace.debug, "_X_DDDDDDDDDDDDDD (Inside the event splitter operator) " +
								"Ignoring the type 3 event asking for daily expenditure with dayInThePast set to 0." +
								" Incoming Type 3 Event=" + (rstring)LRE);
						}
					}
				}
				
				onTuple TS: {
					// Let us see if the entire processing had ended so that we can print a closing line in the log file.
					if ((_eventCnt <= 0ul) || (_linearRoadProcessingEnded == true)) {
						// If the application run has not even started, nothing to do here and simply return back.
						// Do the same thing when the linear road processing had already ended.
						return;
					}
					
					if (_lastKnownEventCnt < _eventCnt) {
						// Linear road processing is actively in progress. Let us keep it going.
						_lastKnownEventCnt = _eventCnt;
					} else if (_lastKnownEventCnt == _eventCnt) {
						// Event count has not changed since we last visited here.
						// That means, Linear Road processing must have ended.
						// Let us print the final message in the PE log.
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)_mostRecentlyReceivedEvent);
						appTrc(Trace.error, "Empty event tuple error count = " + (rstring)_emptyEventsReceivedErrorCnt);
						appTrc(Trace.error, "Type 0 and 3 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType0AndType3EventsReceived);
						appTrc(Trace.error, "Type 2 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType2EventsReceived);
						appTrc(Trace.error, "******* END OF LINEAR ROAD PROCESSING (main application entry point) *******");
						_linearRoadProcessingEnded = true;
					} 
				}
				
			config
				threadedPort: queue(LRE, Sys.Wait);
				// Fuse it with the LR-DataReceiver partition.
				placement: host(lrPool[4]), partitionColocation("LR-DataReceiver15");
		}
		
		// We will split the type 0 position report events to go to the individual instances of
		// the type 0 event processor operator based on a unique combination of
		// "expressWayNumber + directionIndicator".
		<% my $cnt = 0; %>
		(
		 <% for ($cnt = 281; $cnt <= 300; $cnt++) { %>
		 stream<LinearRoadEventType> PositionReport<%=$cnt%><% if ($cnt < 300) { %>; <% }} %>
		) = Split(PositionReport_15 as PR) {				
			param
				file: getApplicationDir() +  "/etc/routing-map-for-type0-events-splitter15.txt";
				key: (rstring)PR.expressWayNumber + "_" + (rstring)PR.directionIndicator;

			config
				// Fuse it with the LR-DataReceiver partition.
				placement: partitionColocation("LR-DataReceiver15");
		} 
// ==================================================================
		// Bank 16
		// Linear Road scenario has 4 event types: 
		// 0) Position reports (real time a.k.a continuous query)
		// 2) Account balance (historical query)
		// 3) Daily expenditure report (historical query)
		// 4) Travel time estimation (historical query)
		//
		// In this application, we will only handle the first three event types and skip the fourth one.
		// Split the incoming data according to the event type in order for them to reach the 
		// appropriate downstream operators capable of processing a specific event.
		//
		// Incoming LR events will arrive here either directly from the data feeder (via TCP) or
		// from an asynchronous messaging system (via kafka).
		// 200x version --> Receive and route data for expressways 150 to 159
		(stream<LinearRoadEventType> PositionReport_16; stream<LinearRoadEventType> DailyExpenditure16) =
			Custom(LREventViaTcp16 as LRE; TimerSignal as TS) {
			logic
				state: {
					mutable uint64 _eventCnt = 0ul;
					mutable uint64 _lastKnownEventCnt = 0ul;
					mutable boolean _linearRoadProcessingEnded = false;
					mutable VehicleExpresswayInfoType _vehicleExpresswayInfoTuple = {};
					mutable map<int32, VehicleExpresswayInfoType> _vehicleExpresswayInfoCache = {};
					mutable LinearRoadEventType _mostRecentlyReceivedEvent = {};
					mutable int32 _emptyEventsReceivedErrorCnt = 0;
					mutable int32 _unconfiguredExpresswayType0AndType3EventsReceived = 0;
					mutable int32 _unconfiguredExpresswayType2EventsReceived = 0;
				}
				
				onTuple LRE: {
					// The LR Data feeder seems to send a completely empty event record with all the
					// attributes set to a value of 0. This happens when the data feeder reaches the
					// very end of the data file. We will catch that event with an invalid vehicleId
					// of 0 and discard it.
					if (LRE.vehicleId <= 0) {
						appTrc(Trace.debug, "_X_EEEEEEEEEEEEEEEEEEEEE (Inside the event splitter operator) " +
							"Received a tuple with an empty vehicle id right after the event " + 
							(rstring)_eventCnt + " and discarded it." +
							" Incoming Event=" + (rstring)LRE);		
						_emptyEventsReceivedErrorCnt++;				
						return;
					}

					// For the 15 xways and 25 xways, we will be using the 50 xways data set since 
					// we didn't generate separate data set files for 15x and 25x. In that case, we will
					// have to discard the LR events that are targetted for an unconfigured expressway.
					// That is what is being done in the next two if blocks.
					//					
					// If the incoming LR event is not for one of the configured expressways, then we can ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) && 
						(LRE.eventType == $POSTION_REPORT_EVENT || LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) && 
						(LRE.expressWayNumber >= <%=$totalNumberOfExpressways%>)) {
						// This LR event is for an expressway that is higher than
						// what is configured in this composite via a PERL variable.
						_unconfiguredExpresswayType0AndType3EventsReceived++;
						return;
					}
					
					// If the incoming Account Balance LR event has a vehicle id that has not been seen in
					// any of the configured expressways, then we will ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) &&
						(LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) &&
						((LRE.vehicleId in _vehicleExpresswayInfoCache) == false)) {
						_unconfiguredExpresswayType2EventsReceived++;
						return;	
					}
					
					// As soon as we receive an LR event, we must record the event reception time.
					// This will be used later to calculate the time we are going to take in processing this event.
					LRE.eventRxTimestamp = getSeconds(getTimestamp());
					_eventCnt++;
					// Let us keep a copy of the most recently received event in a state variable.
					// This will be used to print the very last tuple that came from the data feeder when
					// the entire Linear Road processing is completed.
					assignFrom(_mostRecentlyReceivedEvent, LRE);
					
					// Always print the very first event.
					// After that, print only once for every 500K events.
					if ((_eventCnt == 1ul) || ((_eventCnt % 500000ul) == 0ul))  {
						if (_eventCnt == 1ul) {
							appTrc(Trace.error, "******* START OF LINEAR ROAD PROCESSING (main application entry point) *******");
						}
					
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)LRE);
					}

					// Now, route it to the appropriate event processor based on the event type.
					if (LRE.eventType == $POSTION_REPORT_EVENT) {
						// Store in which expressway a given vehicle is traveling now.
						// This is needed for routing the type 2 account balance queries to the 
						// correct type 0 event processor's parallel channel. See more comments in the
						// following "else if" block.						
						_vehicleExpresswayInfoTuple.expressWayNumber = LRE.expressWayNumber;
						_vehicleExpresswayInfoTuple.directionIndicator = LRE.directionIndicator;
						insertM(_vehicleExpresswayInfoCache, LRE.vehicleId, _vehicleExpresswayInfoTuple);
						submit(LRE, PositionReport_16);
					} else if (LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) {
						// Please note that any account balance query will have to be routed via
						// the position report event processor in order to maintain the tuple arrival order.
						// That will allow the position report event processor to be ready with the
						// balance for a given vehicle by the time the account balance (type 2) query
						// hits this Streams application. So, send a type 2 event to the type 0 event
						// processor which in turn will forward that type 2 event to the correct
						// account balance event processor below.
						// If we don't route a type 2 event via the type 0 event processor, then it will
						// cause cache misses in the DPS store by getting ahead of a more recent type 0
						// event that is still waiting inside the input queue of the very busy position
						// report event processor. Hence, let us make this type 2 event sojourn inside
						// the PositionReportEventProcessor for a little while before it is forwarded from
						// there to its own Type 2 event processor.
						//
						// This is going to be tricky since account balance queries are done only by
						// sending us the vehicle id. So, we have to simply know in which expressway and
						// direction that vehicle was seen last and route this type 2 event to a specific
						// instance of the position report event processor PE. That is why, we are maintaining
						// a separate map to find out a given vehicle's last known expressway and direction.
						//
						if (LRE.vehicleId in _vehicleExpresswayInfoCache) {
							// Assign the last known expressway and direction indicator for this vehicle.
							// With these values, it will land in the correct type 0 event processor where this
							// vehicle is already getting processed. We want this type 2 event to line up
							// behind those type 0 events belonging to a given vehicle.
							LRE.expressWayNumber =  _vehicleExpresswayInfoCache[LRE.vehicleId].expressWayNumber;
							LRE.directionIndicator = _vehicleExpresswayInfoCache[LRE.vehicleId].directionIndicator;
						} else {
							// This vehicle has not yet sent its very first position report to us.
							// That means, a type 2 event is coming much before the very first type 0 event for
							// that vehicle is sent to our application. (This can be double-checked in the data set.)
							// In such cases, we will simply send it to the very first position report event processor that
							// is handling expressway 0 and direction indicatior 0 (eastbound) to get forwarded from
							// there to the type 2 event processor.
							LRE.expressWayNumber =  150;
							LRE.directionIndicator = 0;
						}

						// It will now get shuttled to a particular channel of the PositionReportEventProcessor's parallel
						// region and then get forwarded from there to the type 2 event processor thereby putting it
						// in the right spot to obtain and respond with the most recently updated account balance for
						// a given vehicle. 
						submit(LRE, PositionReport_16);
					} else if (LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) {
						// LR specification says, we should respond to a type 3 event only for those days that were in the past.
						// If this type 3 event asks about the daily expenditure for today i.e. dayInThePast = 0,
						// we can simply ignore it by not sending any response back.
						if (LRE.dayInThePast > 0) {
							submit(LRE, DailyExpenditure16);
						} else {
							// Ignore a type 3 event that is asking about the daily expenditure for the current day.
							appTrc(Trace.debug, "_X_DDDDDDDDDDDDDD (Inside the event splitter operator) " +
								"Ignoring the type 3 event asking for daily expenditure with dayInThePast set to 0." +
								" Incoming Type 3 Event=" + (rstring)LRE);
						}
					}
				}
				
				onTuple TS: {
					// Let us see if the entire processing had ended so that we can print a closing line in the log file.
					if ((_eventCnt <= 0ul) || (_linearRoadProcessingEnded == true)) {
						// If the application run has not even started, nothing to do here and simply return back.
						// Do the same thing when the linear road processing had already ended.
						return;
					}
					
					if (_lastKnownEventCnt < _eventCnt) {
						// Linear road processing is actively in progress. Let us keep it going.
						_lastKnownEventCnt = _eventCnt;
					} else if (_lastKnownEventCnt == _eventCnt) {
						// Event count has not changed since we last visited here.
						// That means, Linear Road processing must have ended.
						// Let us print the final message in the PE log.
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)_mostRecentlyReceivedEvent);
						appTrc(Trace.error, "Empty event tuple error count = " + (rstring)_emptyEventsReceivedErrorCnt);
						appTrc(Trace.error, "Type 0 and 3 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType0AndType3EventsReceived);
						appTrc(Trace.error, "Type 2 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType2EventsReceived);
						appTrc(Trace.error, "******* END OF LINEAR ROAD PROCESSING (main application entry point) *******");
						_linearRoadProcessingEnded = true;
					} 
				}
				
			config
				threadedPort: queue(LRE, Sys.Wait);
				// Fuse it with the LR-DataReceiver partition.
				placement: host(lrPool[0]), partitionColocation("LR-DataReceiver16");
		}
		
		// We will split the type 0 position report events to go to the individual instances of
		// the type 0 event processor operator based on a unique combination of
		// "expressWayNumber + directionIndicator".
		<% my $cnt = 0; %>
		(
		 <% for ($cnt = 301; $cnt <= 320; $cnt++) { %>
		 stream<LinearRoadEventType> PositionReport<%=$cnt%><% if ($cnt < 320) { %>; <% }} %>
		) = Split(PositionReport_16 as PR) {				
			param
				file: getApplicationDir() +  "/etc/routing-map-for-type0-events-splitter16.txt";
				key: (rstring)PR.expressWayNumber + "_" + (rstring)PR.directionIndicator;

			config
				// Fuse it with the LR-DataReceiver partition.
				placement: partitionColocation("LR-DataReceiver16");
		}
// ==================================================================
		// Bank 17
		// Linear Road scenario has 4 event types: 
		// 0) Position reports (real time a.k.a continuous query)
		// 2) Account balance (historical query)
		// 3) Daily expenditure report (historical query)
		// 4) Travel time estimation (historical query)
		//
		// In this application, we will only handle the first three event types and skip the fourth one.
		// Split the incoming data according to the event type in order for them to reach the 
		// appropriate downstream operators capable of processing a specific event.
		//
		// Incoming LR events will arrive here either directly from the data feeder (via TCP) or
		// from an asynchronous messaging system (via kafka).
		// 200x version --> Receive and route data for expressways 160 to 169
		(stream<LinearRoadEventType> PositionReport_17; stream<LinearRoadEventType> DailyExpenditure17) =
			Custom(LREventViaTcp17 as LRE; TimerSignal as TS) {
			logic
				state: {
					mutable uint64 _eventCnt = 0ul;
					mutable uint64 _lastKnownEventCnt = 0ul;
					mutable boolean _linearRoadProcessingEnded = false;
					mutable VehicleExpresswayInfoType _vehicleExpresswayInfoTuple = {};
					mutable map<int32, VehicleExpresswayInfoType> _vehicleExpresswayInfoCache = {};
					mutable LinearRoadEventType _mostRecentlyReceivedEvent = {};
					mutable int32 _emptyEventsReceivedErrorCnt = 0;
					mutable int32 _unconfiguredExpresswayType0AndType3EventsReceived = 0;
					mutable int32 _unconfiguredExpresswayType2EventsReceived = 0;
				}
				
				onTuple LRE: {
					// The LR Data feeder seems to send a completely empty event record with all the
					// attributes set to a value of 0. This happens when the data feeder reaches the
					// very end of the data file. We will catch that event with an invalid vehicleId
					// of 0 and discard it.
					if (LRE.vehicleId <= 0) {
						appTrc(Trace.debug, "_X_EEEEEEEEEEEEEEEEEEEEE (Inside the event splitter operator) " +
							"Received a tuple with an empty vehicle id right after the event " + 
							(rstring)_eventCnt + " and discarded it." +
							" Incoming Event=" + (rstring)LRE);		
						_emptyEventsReceivedErrorCnt++;				
						return;
					}

					// For the 15 xways and 25 xways, we will be using the 50 xways data set since 
					// we didn't generate separate data set files for 15x and 25x. In that case, we will
					// have to discard the LR events that are targetted for an unconfigured expressway.
					// That is what is being done in the next two if blocks.
					//					
					// If the incoming LR event is not for one of the configured expressways, then we can ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) && 
						(LRE.eventType == $POSTION_REPORT_EVENT || LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) && 
						(LRE.expressWayNumber >= <%=$totalNumberOfExpressways%>)) {
						// This LR event is for an expressway that is higher than
						// what is configured in this composite via a PERL variable.
						_unconfiguredExpresswayType0AndType3EventsReceived++;
						return;
					}
					
					// If the incoming Account Balance LR event has a vehicle id that has not been seen in
					// any of the configured expressways, then we will ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) &&
						(LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) &&
						((LRE.vehicleId in _vehicleExpresswayInfoCache) == false)) {
						_unconfiguredExpresswayType2EventsReceived++;
						return;	
					}
					
					// As soon as we receive an LR event, we must record the event reception time.
					// This will be used later to calculate the time we are going to take in processing this event.
					LRE.eventRxTimestamp = getSeconds(getTimestamp());
					_eventCnt++;
					// Let us keep a copy of the most recently received event in a state variable.
					// This will be used to print the very last tuple that came from the data feeder when
					// the entire Linear Road processing is completed.
					assignFrom(_mostRecentlyReceivedEvent, LRE);
					
					// Always print the very first event.
					// After that, print only once for every 500K events.
					if ((_eventCnt == 1ul) || ((_eventCnt % 500000ul) == 0ul))  {
						if (_eventCnt == 1ul) {
							appTrc(Trace.error, "******* START OF LINEAR ROAD PROCESSING (main application entry point) *******");
						}
					
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)LRE);
					}

					// Now, route it to the appropriate event processor based on the event type.
					if (LRE.eventType == $POSTION_REPORT_EVENT) {
						// Store in which expressway a given vehicle is traveling now.
						// This is needed for routing the type 2 account balance queries to the 
						// correct type 0 event processor's parallel channel. See more comments in the
						// following "else if" block.						
						_vehicleExpresswayInfoTuple.expressWayNumber = LRE.expressWayNumber;
						_vehicleExpresswayInfoTuple.directionIndicator = LRE.directionIndicator;
						insertM(_vehicleExpresswayInfoCache, LRE.vehicleId, _vehicleExpresswayInfoTuple);
						submit(LRE, PositionReport_17);
					} else if (LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) {
						// Please note that any account balance query will have to be routed via
						// the position report event processor in order to maintain the tuple arrival order.
						// That will allow the position report event processor to be ready with the
						// balance for a given vehicle by the time the account balance (type 2) query
						// hits this Streams application. So, send a type 2 event to the type 0 event
						// processor which in turn will forward that type 2 event to the correct
						// account balance event processor below.
						// If we don't route a type 2 event via the type 0 event processor, then it will
						// cause cache misses in the DPS store by getting ahead of a more recent type 0
						// event that is still waiting inside the input queue of the very busy position
						// report event processor. Hence, let us make this type 2 event sojourn inside
						// the PositionReportEventProcessor for a little while before it is forwarded from
						// there to its own Type 2 event processor.
						//
						// This is going to be tricky since account balance queries are done only by
						// sending us the vehicle id. So, we have to simply know in which expressway and
						// direction that vehicle was seen last and route this type 2 event to a specific
						// instance of the position report event processor PE. That is why, we are maintaining
						// a separate map to find out a given vehicle's last known expressway and direction.
						//
						if (LRE.vehicleId in _vehicleExpresswayInfoCache) {
							// Assign the last known expressway and direction indicator for this vehicle.
							// With these values, it will land in the correct type 0 event processor where this
							// vehicle is already getting processed. We want this type 2 event to line up
							// behind those type 0 events belonging to a given vehicle.
							LRE.expressWayNumber =  _vehicleExpresswayInfoCache[LRE.vehicleId].expressWayNumber;
							LRE.directionIndicator = _vehicleExpresswayInfoCache[LRE.vehicleId].directionIndicator;
						} else {
							// This vehicle has not yet sent its very first position report to us.
							// That means, a type 2 event is coming much before the very first type 0 event for
							// that vehicle is sent to our application. (This can be double-checked in the data set.)
							// In such cases, we will simply send it to the very first position report event processor that
							// is handling expressway 0 and direction indicatior 0 (eastbound) to get forwarded from
							// there to the type 2 event processor.
							LRE.expressWayNumber =  160;
							LRE.directionIndicator = 0;
						}

						// It will now get shuttled to a particular channel of the PositionReportEventProcessor's parallel
						// region and then get forwarded from there to the type 2 event processor thereby putting it
						// in the right spot to obtain and respond with the most recently updated account balance for
						// a given vehicle. 
						submit(LRE, PositionReport_17);
					} else if (LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) {
						// LR specification says, we should respond to a type 3 event only for those days that were in the past.
						// If this type 3 event asks about the daily expenditure for today i.e. dayInThePast = 0,
						// we can simply ignore it by not sending any response back.
						if (LRE.dayInThePast > 0) {
							submit(LRE, DailyExpenditure17);
						} else {
							// Ignore a type 3 event that is asking about the daily expenditure for the current day.
							appTrc(Trace.debug, "_X_DDDDDDDDDDDDDD (Inside the event splitter operator) " +
								"Ignoring the type 3 event asking for daily expenditure with dayInThePast set to 0." +
								" Incoming Type 3 Event=" + (rstring)LRE);
						}
					}
				}
				
				onTuple TS: {
					// Let us see if the entire processing had ended so that we can print a closing line in the log file.
					if ((_eventCnt <= 0ul) || (_linearRoadProcessingEnded == true)) {
						// If the application run has not even started, nothing to do here and simply return back.
						// Do the same thing when the linear road processing had already ended.
						return;
					}
					
					if (_lastKnownEventCnt < _eventCnt) {
						// Linear road processing is actively in progress. Let us keep it going.
						_lastKnownEventCnt = _eventCnt;
					} else if (_lastKnownEventCnt == _eventCnt) {
						// Event count has not changed since we last visited here.
						// That means, Linear Road processing must have ended.
						// Let us print the final message in the PE log.
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)_mostRecentlyReceivedEvent);
						appTrc(Trace.error, "Empty event tuple error count = " + (rstring)_emptyEventsReceivedErrorCnt);
						appTrc(Trace.error, "Type 0 and 3 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType0AndType3EventsReceived);
						appTrc(Trace.error, "Type 2 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType2EventsReceived);
						appTrc(Trace.error, "******* END OF LINEAR ROAD PROCESSING (main application entry point) *******");
						_linearRoadProcessingEnded = true;
					} 
				}
				
			config
				threadedPort: queue(LRE, Sys.Wait);
				// Fuse it with the LR-DataReceiver partition.
				placement: host(lrPool[1]), partitionColocation("LR-DataReceiver17");
		}
		
		// We will split the type 0 position report events to go to the individual instances of
		// the type 0 event processor operator based on a unique combination of
		// "expressWayNumber + directionIndicator".
		<% my $cnt = 0; %>
		(
		 <% for ($cnt = 321; $cnt <= 340; $cnt++) { %>
		 stream<LinearRoadEventType> PositionReport<%=$cnt%><% if ($cnt < 340) { %>; <% }} %>
		) = Split(PositionReport_17 as PR) {				
			param
				file: getApplicationDir() +  "/etc/routing-map-for-type0-events-splitter17.txt";
				key: (rstring)PR.expressWayNumber + "_" + (rstring)PR.directionIndicator;

			config
				// Fuse it with the LR-DataReceiver partition.
				placement: partitionColocation("LR-DataReceiver17");
		}
// ==================================================================
		// Bank 18
		// Linear Road scenario has 4 event types: 
		// 0) Position reports (real time a.k.a continuous query)
		// 2) Account balance (historical query)
		// 3) Daily expenditure report (historical query)
		// 4) Travel time estimation (historical query)
		//
		// In this application, we will only handle the first three event types and skip the fourth one.
		// Split the incoming data according to the event type in order for them to reach the 
		// appropriate downstream operators capable of processing a specific event.
		//
		// Incoming LR events will arrive here either directly from the data feeder (via TCP) or
		// from an asynchronous messaging system (via kafka).
		// 200x version --> Receive and route data for expressways 170 to 179
		(stream<LinearRoadEventType> PositionReport_18; stream<LinearRoadEventType> DailyExpenditure18) =
			Custom(LREventViaTcp18 as LRE; TimerSignal as TS) {
			logic
				state: {
					mutable uint64 _eventCnt = 0ul;
					mutable uint64 _lastKnownEventCnt = 0ul;
					mutable boolean _linearRoadProcessingEnded = false;
					mutable VehicleExpresswayInfoType _vehicleExpresswayInfoTuple = {};
					mutable map<int32, VehicleExpresswayInfoType> _vehicleExpresswayInfoCache = {};
					mutable LinearRoadEventType _mostRecentlyReceivedEvent = {};
					mutable int32 _emptyEventsReceivedErrorCnt = 0;
					mutable int32 _unconfiguredExpresswayType0AndType3EventsReceived = 0;
					mutable int32 _unconfiguredExpresswayType2EventsReceived = 0;
				}
				
				onTuple LRE: {
					// The LR Data feeder seems to send a completely empty event record with all the
					// attributes set to a value of 0. This happens when the data feeder reaches the
					// very end of the data file. We will catch that event with an invalid vehicleId
					// of 0 and discard it.
					if (LRE.vehicleId <= 0) {
						appTrc(Trace.debug, "_X_EEEEEEEEEEEEEEEEEEEEE (Inside the event splitter operator) " +
							"Received a tuple with an empty vehicle id right after the event " + 
							(rstring)_eventCnt + " and discarded it." +
							" Incoming Event=" + (rstring)LRE);		
						_emptyEventsReceivedErrorCnt++;				
						return;
					}

					// For the 15 xways and 25 xways, we will be using the 50 xways data set since 
					// we didn't generate separate data set files for 15x and 25x. In that case, we will
					// have to discard the LR events that are targetted for an unconfigured expressway.
					// That is what is being done in the next two if blocks.
					//					
					// If the incoming LR event is not for one of the configured expressways, then we can ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) && 
						(LRE.eventType == $POSTION_REPORT_EVENT || LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) && 
						(LRE.expressWayNumber >= <%=$totalNumberOfExpressways%>)) {
						// This LR event is for an expressway that is higher than
						// what is configured in this composite via a PERL variable.
						_unconfiguredExpresswayType0AndType3EventsReceived++;
						return;
					}
					
					// If the incoming Account Balance LR event has a vehicle id that has not been seen in
					// any of the configured expressways, then we will ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) &&
						(LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) &&
						((LRE.vehicleId in _vehicleExpresswayInfoCache) == false)) {
						_unconfiguredExpresswayType2EventsReceived++;
						return;	
					}
					
					// As soon as we receive an LR event, we must record the event reception time.
					// This will be used later to calculate the time we are going to take in processing this event.
					LRE.eventRxTimestamp = getSeconds(getTimestamp());
					_eventCnt++;
					// Let us keep a copy of the most recently received event in a state variable.
					// This will be used to print the very last tuple that came from the data feeder when
					// the entire Linear Road processing is completed.
					assignFrom(_mostRecentlyReceivedEvent, LRE);
					
					// Always print the very first event.
					// After that, print only once for every 500K events.
					if ((_eventCnt == 1ul) || ((_eventCnt % 500000ul) == 0ul))  {
						if (_eventCnt == 1ul) {
							appTrc(Trace.error, "******* START OF LINEAR ROAD PROCESSING (main application entry point) *******");
						}
					
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)LRE);
					}

					// Now, route it to the appropriate event processor based on the event type.
					if (LRE.eventType == $POSTION_REPORT_EVENT) {
						// Store in which expressway a given vehicle is traveling now.
						// This is needed for routing the type 2 account balance queries to the 
						// correct type 0 event processor's parallel channel. See more comments in the
						// following "else if" block.						
						_vehicleExpresswayInfoTuple.expressWayNumber = LRE.expressWayNumber;
						_vehicleExpresswayInfoTuple.directionIndicator = LRE.directionIndicator;
						insertM(_vehicleExpresswayInfoCache, LRE.vehicleId, _vehicleExpresswayInfoTuple);
						submit(LRE, PositionReport_18);
					} else if (LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) {
						// Please note that any account balance query will have to be routed via
						// the position report event processor in order to maintain the tuple arrival order.
						// That will allow the position report event processor to be ready with the
						// balance for a given vehicle by the time the account balance (type 2) query
						// hits this Streams application. So, send a type 2 event to the type 0 event
						// processor which in turn will forward that type 2 event to the correct
						// account balance event processor below.
						// If we don't route a type 2 event via the type 0 event processor, then it will
						// cause cache misses in the DPS store by getting ahead of a more recent type 0
						// event that is still waiting inside the input queue of the very busy position
						// report event processor. Hence, let us make this type 2 event sojourn inside
						// the PositionReportEventProcessor for a little while before it is forwarded from
						// there to its own Type 2 event processor.
						//
						// This is going to be tricky since account balance queries are done only by
						// sending us the vehicle id. So, we have to simply know in which expressway and
						// direction that vehicle was seen last and route this type 2 event to a specific
						// instance of the position report event processor PE. That is why, we are maintaining
						// a separate map to find out a given vehicle's last known expressway and direction.
						//
						if (LRE.vehicleId in _vehicleExpresswayInfoCache) {
							// Assign the last known expressway and direction indicator for this vehicle.
							// With these values, it will land in the correct type 0 event processor where this
							// vehicle is already getting processed. We want this type 2 event to line up
							// behind those type 0 events belonging to a given vehicle.
							LRE.expressWayNumber =  _vehicleExpresswayInfoCache[LRE.vehicleId].expressWayNumber;
							LRE.directionIndicator = _vehicleExpresswayInfoCache[LRE.vehicleId].directionIndicator;
						} else {
							// This vehicle has not yet sent its very first position report to us.
							// That means, a type 2 event is coming much before the very first type 0 event for
							// that vehicle is sent to our application. (This can be double-checked in the data set.)
							// In such cases, we will simply send it to the very first position report event processor that
							// is handling expressway 0 and direction indicatior 0 (eastbound) to get forwarded from
							// there to the type 2 event processor.
							LRE.expressWayNumber =  170;
							LRE.directionIndicator = 0;
						}

						// It will now get shuttled to a particular channel of the PositionReportEventProcessor's parallel
						// region and then get forwarded from there to the type 2 event processor thereby putting it
						// in the right spot to obtain and respond with the most recently updated account balance for
						// a given vehicle. 
						submit(LRE, PositionReport_18);
					} else if (LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) {
						// LR specification says, we should respond to a type 3 event only for those days that were in the past.
						// If this type 3 event asks about the daily expenditure for today i.e. dayInThePast = 0,
						// we can simply ignore it by not sending any response back.
						if (LRE.dayInThePast > 0) {
							submit(LRE, DailyExpenditure18);
						} else {
							// Ignore a type 3 event that is asking about the daily expenditure for the current day.
							appTrc(Trace.debug, "_X_DDDDDDDDDDDDDD (Inside the event splitter operator) " +
								"Ignoring the type 3 event asking for daily expenditure with dayInThePast set to 0." +
								" Incoming Type 3 Event=" + (rstring)LRE);
						}
					}
				}
				
				onTuple TS: {
					// Let us see if the entire processing had ended so that we can print a closing line in the log file.
					if ((_eventCnt <= 0ul) || (_linearRoadProcessingEnded == true)) {
						// If the application run has not even started, nothing to do here and simply return back.
						// Do the same thing when the linear road processing had already ended.
						return;
					}
					
					if (_lastKnownEventCnt < _eventCnt) {
						// Linear road processing is actively in progress. Let us keep it going.
						_lastKnownEventCnt = _eventCnt;
					} else if (_lastKnownEventCnt == _eventCnt) {
						// Event count has not changed since we last visited here.
						// That means, Linear Road processing must have ended.
						// Let us print the final message in the PE log.
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)_mostRecentlyReceivedEvent);
						appTrc(Trace.error, "Empty event tuple error count = " + (rstring)_emptyEventsReceivedErrorCnt);
						appTrc(Trace.error, "Type 0 and 3 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType0AndType3EventsReceived);
						appTrc(Trace.error, "Type 2 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType2EventsReceived);
						appTrc(Trace.error, "******* END OF LINEAR ROAD PROCESSING (main application entry point) *******");
						_linearRoadProcessingEnded = true;
					} 
				}
				
			config
				threadedPort: queue(LRE, Sys.Wait);
				// Fuse it with the LR-DataReceiver partition.
				placement: host(lrPool[3]), partitionColocation("LR-DataReceiver18");
		}
		
		// We will split the type 0 position report events to go to the individual instances of
		// the type 0 event processor operator based on a unique combination of
		// "expressWayNumber + directionIndicator".
		<% my $cnt = 0; %>
		(
		 <% for ($cnt = 341; $cnt <= 360; $cnt++) { %>
		 stream<LinearRoadEventType> PositionReport<%=$cnt%><% if ($cnt < 360) { %>; <% }} %>
		) = Split(PositionReport_18 as PR) {				
			param
				file: getApplicationDir() +  "/etc/routing-map-for-type0-events-splitter18.txt";
				key: (rstring)PR.expressWayNumber + "_" + (rstring)PR.directionIndicator;

			config
				// Fuse it with the LR-DataReceiver partition.
				placement: partitionColocation("LR-DataReceiver18");
		}
// ==================================================================
		// Bank 19
		// Linear Road scenario has 4 event types: 
		// 0) Position reports (real time a.k.a continuous query)
		// 2) Account balance (historical query)
		// 3) Daily expenditure report (historical query)
		// 4) Travel time estimation (historical query)
		//
		// In this application, we will only handle the first three event types and skip the fourth one.
		// Split the incoming data according to the event type in order for them to reach the 
		// appropriate downstream operators capable of processing a specific event.
		//
		// Incoming LR events will arrive here either directly from the data feeder (via TCP) or
		// from an asynchronous messaging system (via kafka).
		// 200x version --> Receive and route data for expressways 180 to 189
		(stream<LinearRoadEventType> PositionReport_19; stream<LinearRoadEventType> DailyExpenditure19) =
			Custom(LREventViaTcp19 as LRE; TimerSignal as TS) {
			logic
				state: {
					mutable uint64 _eventCnt = 0ul;
					mutable uint64 _lastKnownEventCnt = 0ul;
					mutable boolean _linearRoadProcessingEnded = false;
					mutable VehicleExpresswayInfoType _vehicleExpresswayInfoTuple = {};
					mutable map<int32, VehicleExpresswayInfoType> _vehicleExpresswayInfoCache = {};
					mutable LinearRoadEventType _mostRecentlyReceivedEvent = {};
					mutable int32 _emptyEventsReceivedErrorCnt = 0;
					mutable int32 _unconfiguredExpresswayType0AndType3EventsReceived = 0;
					mutable int32 _unconfiguredExpresswayType2EventsReceived = 0;
				}
				
				onTuple LRE: {
					// The LR Data feeder seems to send a completely empty event record with all the
					// attributes set to a value of 0. This happens when the data feeder reaches the
					// very end of the data file. We will catch that event with an invalid vehicleId
					// of 0 and discard it.
					if (LRE.vehicleId <= 0) {
						appTrc(Trace.debug, "_X_EEEEEEEEEEEEEEEEEEEEE (Inside the event splitter operator) " +
							"Received a tuple with an empty vehicle id right after the event " + 
							(rstring)_eventCnt + " and discarded it." +
							" Incoming Event=" + (rstring)LRE);		
						_emptyEventsReceivedErrorCnt++;				
						return;
					}

					// For the 15 xways and 25 xways, we will be using the 50 xways data set since 
					// we didn't generate separate data set files for 15x and 25x. In that case, we will
					// have to discard the LR events that are targetted for an unconfigured expressway.
					// That is what is being done in the next two if blocks.
					//					
					// If the incoming LR event is not for one of the configured expressways, then we can ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) && 
						(LRE.eventType == $POSTION_REPORT_EVENT || LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) && 
						(LRE.expressWayNumber >= <%=$totalNumberOfExpressways%>)) {
						// This LR event is for an expressway that is higher than
						// what is configured in this composite via a PERL variable.
						_unconfiguredExpresswayType0AndType3EventsReceived++;
						return;
					}
					
					// If the incoming Account Balance LR event has a vehicle id that has not been seen in
					// any of the configured expressways, then we will ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) &&
						(LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) &&
						((LRE.vehicleId in _vehicleExpresswayInfoCache) == false)) {
						_unconfiguredExpresswayType2EventsReceived++;
						return;	
					}
					
					// As soon as we receive an LR event, we must record the event reception time.
					// This will be used later to calculate the time we are going to take in processing this event.
					LRE.eventRxTimestamp = getSeconds(getTimestamp());
					_eventCnt++;
					// Let us keep a copy of the most recently received event in a state variable.
					// This will be used to print the very last tuple that came from the data feeder when
					// the entire Linear Road processing is completed.
					assignFrom(_mostRecentlyReceivedEvent, LRE);
					
					// Always print the very first event.
					// After that, print only once for every 500K events.
					if ((_eventCnt == 1ul) || ((_eventCnt % 500000ul) == 0ul))  {
						if (_eventCnt == 1ul) {
							appTrc(Trace.error, "******* START OF LINEAR ROAD PROCESSING (main application entry point) *******");
						}
					
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)LRE);
					}

					// Now, route it to the appropriate event processor based on the event type.
					if (LRE.eventType == $POSTION_REPORT_EVENT) {
						// Store in which expressway a given vehicle is traveling now.
						// This is needed for routing the type 2 account balance queries to the 
						// correct type 0 event processor's parallel channel. See more comments in the
						// following "else if" block.						
						_vehicleExpresswayInfoTuple.expressWayNumber = LRE.expressWayNumber;
						_vehicleExpresswayInfoTuple.directionIndicator = LRE.directionIndicator;
						insertM(_vehicleExpresswayInfoCache, LRE.vehicleId, _vehicleExpresswayInfoTuple);
						submit(LRE, PositionReport_19);
					} else if (LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) {
						// Please note that any account balance query will have to be routed via
						// the position report event processor in order to maintain the tuple arrival order.
						// That will allow the position report event processor to be ready with the
						// balance for a given vehicle by the time the account balance (type 2) query
						// hits this Streams application. So, send a type 2 event to the type 0 event
						// processor which in turn will forward that type 2 event to the correct
						// account balance event processor below.
						// If we don't route a type 2 event via the type 0 event processor, then it will
						// cause cache misses in the DPS store by getting ahead of a more recent type 0
						// event that is still waiting inside the input queue of the very busy position
						// report event processor. Hence, let us make this type 2 event sojourn inside
						// the PositionReportEventProcessor for a little while before it is forwarded from
						// there to its own Type 2 event processor.
						//
						// This is going to be tricky since account balance queries are done only by
						// sending us the vehicle id. So, we have to simply know in which expressway and
						// direction that vehicle was seen last and route this type 2 event to a specific
						// instance of the position report event processor PE. That is why, we are maintaining
						// a separate map to find out a given vehicle's last known expressway and direction.
						//
						if (LRE.vehicleId in _vehicleExpresswayInfoCache) {
							// Assign the last known expressway and direction indicator for this vehicle.
							// With these values, it will land in the correct type 0 event processor where this
							// vehicle is already getting processed. We want this type 2 event to line up
							// behind those type 0 events belonging to a given vehicle.
							LRE.expressWayNumber =  _vehicleExpresswayInfoCache[LRE.vehicleId].expressWayNumber;
							LRE.directionIndicator = _vehicleExpresswayInfoCache[LRE.vehicleId].directionIndicator;
						} else {
							// This vehicle has not yet sent its very first position report to us.
							// That means, a type 2 event is coming much before the very first type 0 event for
							// that vehicle is sent to our application. (This can be double-checked in the data set.)
							// In such cases, we will simply send it to the very first position report event processor that
							// is handling expressway 0 and direction indicatior 0 (eastbound) to get forwarded from
							// there to the type 2 event processor.
							LRE.expressWayNumber =  180;
							LRE.directionIndicator = 0;
						}

						// It will now get shuttled to a particular channel of the PositionReportEventProcessor's parallel
						// region and then get forwarded from there to the type 2 event processor thereby putting it
						// in the right spot to obtain and respond with the most recently updated account balance for
						// a given vehicle. 
						submit(LRE, PositionReport_19);
					} else if (LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) {
						// LR specification says, we should respond to a type 3 event only for those days that were in the past.
						// If this type 3 event asks about the daily expenditure for today i.e. dayInThePast = 0,
						// we can simply ignore it by not sending any response back.
						if (LRE.dayInThePast > 0) {
							submit(LRE, DailyExpenditure19);
						} else {
							// Ignore a type 3 event that is asking about the daily expenditure for the current day.
							appTrc(Trace.debug, "_X_DDDDDDDDDDDDDD (Inside the event splitter operator) " +
								"Ignoring the type 3 event asking for daily expenditure with dayInThePast set to 0." +
								" Incoming Type 3 Event=" + (rstring)LRE);
						}
					}
				}
				
				onTuple TS: {
					// Let us see if the entire processing had ended so that we can print a closing line in the log file.
					if ((_eventCnt <= 0ul) || (_linearRoadProcessingEnded == true)) {
						// If the application run has not even started, nothing to do here and simply return back.
						// Do the same thing when the linear road processing had already ended.
						return;
					}
					
					if (_lastKnownEventCnt < _eventCnt) {
						// Linear road processing is actively in progress. Let us keep it going.
						_lastKnownEventCnt = _eventCnt;
					} else if (_lastKnownEventCnt == _eventCnt) {
						// Event count has not changed since we last visited here.
						// That means, Linear Road processing must have ended.
						// Let us print the final message in the PE log.
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)_mostRecentlyReceivedEvent);
						appTrc(Trace.error, "Empty event tuple error count = " + (rstring)_emptyEventsReceivedErrorCnt);
						appTrc(Trace.error, "Type 0 and 3 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType0AndType3EventsReceived);
						appTrc(Trace.error, "Type 2 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType2EventsReceived);
						appTrc(Trace.error, "******* END OF LINEAR ROAD PROCESSING (main application entry point) *******");
						_linearRoadProcessingEnded = true;
					} 
				}
				
			config
				threadedPort: queue(LRE, Sys.Wait);
				// Fuse it with the LR-DataReceiver partition.
				placement: host(lrPool[4]), partitionColocation("LR-DataReceiver19");
		}
		
		// We will split the type 0 position report events to go to the individual instances of
		// the type 0 event processor operator based on a unique combination of
		// "expressWayNumber + directionIndicator".
		<% my $cnt = 0; %>
		(
		 <% for ($cnt = 361; $cnt <= 380; $cnt++) { %>
		 stream<LinearRoadEventType> PositionReport<%=$cnt%><% if ($cnt < 380) { %>; <% }} %>
		) = Split(PositionReport_19 as PR) {				
			param
				file: getApplicationDir() +  "/etc/routing-map-for-type0-events-splitter19.txt";
				key: (rstring)PR.expressWayNumber + "_" + (rstring)PR.directionIndicator;

			config
				// Fuse it with the LR-DataReceiver partition.
				placement: partitionColocation("LR-DataReceiver19");
		}
// ==================================================================
		// Bank 20
		// Linear Road scenario has 4 event types: 
		// 0) Position reports (real time a.k.a continuous query)
		// 2) Account balance (historical query)
		// 3) Daily expenditure report (historical query)
		// 4) Travel time estimation (historical query)
		//
		// In this application, we will only handle the first three event types and skip the fourth one.
		// Split the incoming data according to the event type in order for them to reach the 
		// appropriate downstream operators capable of processing a specific event.
		//
		// Incoming LR events will arrive here either directly from the data feeder (via TCP) or
		// from an asynchronous messaging system (via kafka).
		// 200x version --> Receive and route data for expressways 190 to 199
		(stream<LinearRoadEventType> PositionReport_20; stream<LinearRoadEventType> DailyExpenditure20) =
			Custom(LREventViaTcp20 as LRE; TimerSignal as TS) {
			logic
				state: {
					mutable uint64 _eventCnt = 0ul;
					mutable uint64 _lastKnownEventCnt = 0ul;
					mutable boolean _linearRoadProcessingEnded = false;
					mutable VehicleExpresswayInfoType _vehicleExpresswayInfoTuple = {};
					mutable map<int32, VehicleExpresswayInfoType> _vehicleExpresswayInfoCache = {};
					mutable LinearRoadEventType _mostRecentlyReceivedEvent = {};
					mutable int32 _emptyEventsReceivedErrorCnt = 0;
					mutable int32 _unconfiguredExpresswayType0AndType3EventsReceived = 0;
					mutable int32 _unconfiguredExpresswayType2EventsReceived = 0;
				}
				
				onTuple LRE: {
					// The LR Data feeder seems to send a completely empty event record with all the
					// attributes set to a value of 0. This happens when the data feeder reaches the
					// very end of the data file. We will catch that event with an invalid vehicleId
					// of 0 and discard it.
					if (LRE.vehicleId <= 0) {
						appTrc(Trace.debug, "_X_EEEEEEEEEEEEEEEEEEEEE (Inside the event splitter operator) " +
							"Received a tuple with an empty vehicle id right after the event " + 
							(rstring)_eventCnt + " and discarded it." +
							" Incoming Event=" + (rstring)LRE);		
						_emptyEventsReceivedErrorCnt++;				
						return;
					}

					// For the 15 xways and 25 xways, we will be using the 50 xways data set since 
					// we didn't generate separate data set files for 15x and 25x. In that case, we will
					// have to discard the LR events that are targetted for an unconfigured expressway.
					// That is what is being done in the next two if blocks.
					//					
					// If the incoming LR event is not for one of the configured expressways, then we can ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) && 
						(LRE.eventType == $POSTION_REPORT_EVENT || LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) && 
						(LRE.expressWayNumber >= <%=$totalNumberOfExpressways%>)) {
						// This LR event is for an expressway that is higher than
						// what is configured in this composite via a PERL variable.
						_unconfiguredExpresswayType0AndType3EventsReceived++;
						return;
					}
					
					// If the incoming Account Balance LR event has a vehicle id that has not been seen in
					// any of the configured expressways, then we will ignore it.
					if ((<%=$totalNumberOfExpressways%> == 15 || <%=$totalNumberOfExpressways%> == 25) &&
						(LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) &&
						((LRE.vehicleId in _vehicleExpresswayInfoCache) == false)) {
						_unconfiguredExpresswayType2EventsReceived++;
						return;	
					}
					
					// As soon as we receive an LR event, we must record the event reception time.
					// This will be used later to calculate the time we are going to take in processing this event.
					LRE.eventRxTimestamp = getSeconds(getTimestamp());
					_eventCnt++;
					// Let us keep a copy of the most recently received event in a state variable.
					// This will be used to print the very last tuple that came from the data feeder when
					// the entire Linear Road processing is completed.
					assignFrom(_mostRecentlyReceivedEvent, LRE);
					
					// Always print the very first event.
					// After that, print only once for every 500K events.
					if ((_eventCnt == 1ul) || ((_eventCnt % 500000ul) == 0ul))  {
						if (_eventCnt == 1ul) {
							appTrc(Trace.error, "******* START OF LINEAR ROAD PROCESSING (main application entry point) *******");
						}
					
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)LRE);
					}

					// Now, route it to the appropriate event processor based on the event type.
					if (LRE.eventType == $POSTION_REPORT_EVENT) {
						// Store in which expressway a given vehicle is traveling now.
						// This is needed for routing the type 2 account balance queries to the 
						// correct type 0 event processor's parallel channel. See more comments in the
						// following "else if" block.						
						_vehicleExpresswayInfoTuple.expressWayNumber = LRE.expressWayNumber;
						_vehicleExpresswayInfoTuple.directionIndicator = LRE.directionIndicator;
						insertM(_vehicleExpresswayInfoCache, LRE.vehicleId, _vehicleExpresswayInfoTuple);
						submit(LRE, PositionReport_20);
					} else if (LRE.eventType == $ACCOUNT_BALANCE_QUERY_EVENT) {
						// Please note that any account balance query will have to be routed via
						// the position report event processor in order to maintain the tuple arrival order.
						// That will allow the position report event processor to be ready with the
						// balance for a given vehicle by the time the account balance (type 2) query
						// hits this Streams application. So, send a type 2 event to the type 0 event
						// processor which in turn will forward that type 2 event to the correct
						// account balance event processor below.
						// If we don't route a type 2 event via the type 0 event processor, then it will
						// cause cache misses in the DPS store by getting ahead of a more recent type 0
						// event that is still waiting inside the input queue of the very busy position
						// report event processor. Hence, let us make this type 2 event sojourn inside
						// the PositionReportEventProcessor for a little while before it is forwarded from
						// there to its own Type 2 event processor.
						//
						// This is going to be tricky since account balance queries are done only by
						// sending us the vehicle id. So, we have to simply know in which expressway and
						// direction that vehicle was seen last and route this type 2 event to a specific
						// instance of the position report event processor PE. That is why, we are maintaining
						// a separate map to find out a given vehicle's last known expressway and direction.
						//
						if (LRE.vehicleId in _vehicleExpresswayInfoCache) {
							// Assign the last known expressway and direction indicator for this vehicle.
							// With these values, it will land in the correct type 0 event processor where this
							// vehicle is already getting processed. We want this type 2 event to line up
							// behind those type 0 events belonging to a given vehicle.
							LRE.expressWayNumber =  _vehicleExpresswayInfoCache[LRE.vehicleId].expressWayNumber;
							LRE.directionIndicator = _vehicleExpresswayInfoCache[LRE.vehicleId].directionIndicator;
						} else {
							// This vehicle has not yet sent its very first position report to us.
							// That means, a type 2 event is coming much before the very first type 0 event for
							// that vehicle is sent to our application. (This can be double-checked in the data set.)
							// In such cases, we will simply send it to the very first position report event processor that
							// is handling expressway 0 and direction indicatior 0 (eastbound) to get forwarded from
							// there to the type 2 event processor.
							LRE.expressWayNumber =  190;
							LRE.directionIndicator = 0;
						}

						// It will now get shuttled to a particular channel of the PositionReportEventProcessor's parallel
						// region and then get forwarded from there to the type 2 event processor thereby putting it
						// in the right spot to obtain and respond with the most recently updated account balance for
						// a given vehicle. 
						submit(LRE, PositionReport_20);
					} else if (LRE.eventType == $DAILY_EXPENDITURE_QUERY_EVENT) {
						// LR specification says, we should respond to a type 3 event only for those days that were in the past.
						// If this type 3 event asks about the daily expenditure for today i.e. dayInThePast = 0,
						// we can simply ignore it by not sending any response back.
						if (LRE.dayInThePast > 0) {
							submit(LRE, DailyExpenditure20);
						} else {
							// Ignore a type 3 event that is asking about the daily expenditure for the current day.
							appTrc(Trace.debug, "_X_DDDDDDDDDDDDDD (Inside the event splitter operator) " +
								"Ignoring the type 3 event asking for daily expenditure with dayInThePast set to 0." +
								" Incoming Type 3 Event=" + (rstring)LRE);
						}
					}
				}
				
				onTuple TS: {
					// Let us see if the entire processing had ended so that we can print a closing line in the log file.
					if ((_eventCnt <= 0ul) || (_linearRoadProcessingEnded == true)) {
						// If the application run has not even started, nothing to do here and simply return back.
						// Do the same thing when the linear road processing had already ended.
						return;
					}
					
					if (_lastKnownEventCnt < _eventCnt) {
						// Linear road processing is actively in progress. Let us keep it going.
						_lastKnownEventCnt = _eventCnt;
					} else if (_lastKnownEventCnt == _eventCnt) {
						// Event count has not changed since we last visited here.
						// That means, Linear Road processing must have ended.
						// Let us print the final message in the PE log.
						appTrc(Trace.error, "Event " + (rstring)_eventCnt + "-->" + (rstring)_mostRecentlyReceivedEvent);
						appTrc(Trace.error, "Empty event tuple error count = " + (rstring)_emptyEventsReceivedErrorCnt);
						appTrc(Trace.error, "Type 0 and 3 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType0AndType3EventsReceived);
						appTrc(Trace.error, "Type 2 events received for unconfigured expressways = " + 
							(rstring)_unconfiguredExpresswayType2EventsReceived);
						appTrc(Trace.error, "******* END OF LINEAR ROAD PROCESSING (main application entry point) *******");
						_linearRoadProcessingEnded = true;
					} 
				}
				
			config
				threadedPort: queue(LRE, Sys.Wait);
				// Fuse it with the LR-DataReceiver partition.
				placement: host(lrPool[0]), partitionColocation("LR-DataReceiver20");
		}
		
		// We will split the type 0 position report events to go to the individual instances of
		// the type 0 event processor operator based on a unique combination of
		// "expressWayNumber + directionIndicator".
		<% my $cnt = 0; %>
		(
		 <% for ($cnt = 381; $cnt <= 400; $cnt++) { %>
		 stream<LinearRoadEventType> PositionReport<%=$cnt%><% if ($cnt < 400) { %>; <% }} %>
		) = Split(PositionReport_20 as PR) {				
			param
				file: getApplicationDir() +  "/etc/routing-map-for-type0-events-splitter20.txt";
				key: (rstring)PR.expressWayNumber + "_" + (rstring)PR.directionIndicator;

			config
				// Fuse it with the LR-DataReceiver partition.
				placement: partitionColocation("LR-DataReceiver20");
		}


// ****************** Event splitter logic ends here ******************

// ****************** Type 0 event processing logic begins here ******************
		// Let us take care of handling the position reports.
		// This event forms the major portion of the total data volume in all of the Linear Road tests.
		// Main purpose of this event is to evaluate how quickly we can process these
		// events by maintaining the application state over a long period of this test and
		// then by sending out accurate responses within the best possible time.
		// Type 0 event accounts for 99% of the total traffic that will be sent
		// our way and the remaining 1% of the total traffic will be for historical queries.
		//		
		// We will create a dedicated instance of the following operator for all the position reports arriving for
		// a particular expressway and for the traffic flowing in a particular direction.
		<% for ($cnt = 1; $cnt <= $totalPositionReportEngines; $cnt++) { %>
		(stream<FinalOutputType> TollNotificationOutput<%=$cnt%>;
		 stream<FinalOutputType> AccidentAlertOutput<%=$cnt%>;
		 stream<AccountBalanceResultType> AccountBalanceResult<%=$cnt%>) =
		 	PositionReportEventProcessor(PositionReport<%=$cnt%> as PR; TimerSignal as TS) {
			config
				<%
					# We will fuse type 0 event processors belonging to every few
					# expressways into a single PE.
					my $fusionId = (($cnt-1)/$totalNumberOfPositionReportEnginesInFusedPe) + 1;
					my $fusionIdString = "Position-Report-Analysis-" . $fusionId;
				%>
						
				// Run it on a different machine away from the DataFeeder.
				placement: host(lrPool[0]), partitionColocation("<%=$fusionIdString%>");
		}
		<% } %>
// ****************** Type 0 event processing logic ends here ******************

// ****************** Type 2 event processing logic begins here ******************
		// Let us take care of responding to the Type 2 historical query (Account Balance).
		// This test is done by intermixing a historical query in the middle of a
		// high volume Type 0 Position Report real time events. It is done to evaluate
		// how quickly we can respond to such a historical query that should return
		// a result based on a moving toll balance calculation.
		// Type 2 event accounts for 50% of the total historical queries that will be sent our way.
		stream<FinalOutputType> AccountBalanceOutput = 
			AccountBalanceEventProcessor(
			<% for ($cnt = 1; $cnt <= $totalPositionReportEngines; $cnt++) { %>AccountBalanceResult<%=$cnt%><% if ($cnt < $totalPositionReportEngines) { %>, <% }} %>) { 
			config
				// Run it on a different machine away from the DataFeeder.
				placement: host(lrPool[0]), partitionColocation("AccountBalance");
		}
// ****************** Type 2 event processing logic ends here ******************

// ****************** Type 3 event processing logic begins here ******************
		// Let us take care of responding to the Type 3 historical query (Daily Expenditure Report).
		// This test is done primarily to measure how quickly we can respond to a historical query with
		// a potential to look-up the answer from a reference data set of 100 million entries.
		// Type 3 event accounts for 10% of the total historical queries that will be sent our way.
		// 100x version
		stream<FinalOutputType> DailyExpenditureOutput = DailyExpenditureEventProcessor(
			DailyExpenditure1, DailyExpenditure2, DailyExpenditure3, DailyExpenditure4, DailyExpenditure5) { 
			config
				// Run it on a different machine away from the DataFeeder.
				placement: host(lrPool[0]), partitionColocation("DailyExpenditure");
		}		
// ****************** Type 3 event processing logic ends here ******************

// ****************** Final output writing logic begins here ******************
		//
		// Linear or non-linear, all roads must end here!!!
		//
		// Our final output file carrying all the  Type0 results will be written
		// via this operator. Whoever is feeding this operator must transform their
		// output into a single string attribute and send it here.
		() as TollNotificationFinalOutput = 
			FileSink(
			<% for ($cnt = 1; $cnt <= $totalPositionReportEngines; $cnt++) { %>TollNotificationOutput<%=$cnt%><% if ($cnt < $totalPositionReportEngines) { %>, <% }} %>) {
			param
				file: $LINEAR_ROAD_FINAL_TYPE0_OUTPUT_FILE;
				quoteStrings: false;
				
			config
				// Place it on the same machine as the PositionReport operator.
				// We don't want to fuse it with the parallel regioned PositionReport operator.
				placement: host(lrPool[0]);	
		}			

		// Our final output file carrying all the  Type1 results will be written
		// via this operator. Whoever is feeding this operator must transform their
		// output into a single string attribute and send it here.
		() as AccidentAlertFinalOutput = 
			FileSink(
			<% for ($cnt = 1; $cnt <= $totalPositionReportEngines; $cnt++) { %>AccidentAlertOutput<%=$cnt%><% if ($cnt < $totalPositionReportEngines) { %>, <% }} %>) {
			param
				file: $LINEAR_ROAD_FINAL_TYPE1_OUTPUT_FILE;
				quoteStrings: false;
				
			config
				// Place it on the same machine as the PositionReport operator.
				// We don't want to fuse it with the parallel regioned PositionReport operator.
				placement: host(lrPool[0]);	
		}	
		
		// Our final output file carrying all the  Type2 results will be written
		// via this operator. Whoever is feeding this operator must transform their
		// output into a single string attribute and send it here.
		() as AccountBalanceFinalOutput = FileSink(AccountBalanceOutput) {
			param
				file: $LINEAR_ROAD_FINAL_TYPE2_OUTPUT_FILE;
				quoteStrings: false;
				
			config
				// Fuse it with the AccountBalance calculation Functor operator above.
				placement: partitionColocation("AccountBalance");	
		}		
		
		// Our final output file carrying all the  Type3 results will be written
		// via this operator. Whoever is feeding this operator must transform their
		// output into a single string attribute and send it here.
		() as DailyExpenditureFinalOutput = FileSink(DailyExpenditureOutput) {
			param
				file: $LINEAR_ROAD_FINAL_TYPE3_OUTPUT_FILE;
				quoteStrings: false;
				
			config
				// Fuse it with the DailyExpenditure calculation Functor operator above.
				placement: partitionColocation("DailyExpenditure");
		}
// ****************** Final output writing logic ends here ******************
				
	config
		// Machines below were used in a particular lab where we tested this.
		// Make a host pool with three application machines from your own Streams environment.		
		// hostPool: lrPool = ["10.0.0.6", "10.0.0.7", "10.0.0.8"];
		hostPool: lrPool = ["vendor3", "vendor4", "vendor5", "vendor2", "vendor1"];
}
