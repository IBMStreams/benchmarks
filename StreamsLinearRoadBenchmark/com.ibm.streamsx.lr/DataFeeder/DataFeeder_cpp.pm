
package DataFeeder_cpp;
use strict; use Cwd 'realpath';  use File::Basename;  use lib dirname(__FILE__);  use SPL::Operator::Instance::OperatorInstance; use SPL::Operator::Instance::Annotation; use SPL::Operator::Instance::Context; use SPL::Operator::Instance::Expression; use SPL::Operator::Instance::ExpressionTree; use SPL::Operator::Instance::ExpressionTreeEvaluator; use SPL::Operator::Instance::ExpressionTreeVisitor; use SPL::Operator::Instance::ExpressionTreeCppGenVisitor; use SPL::Operator::Instance::InputAttribute; use SPL::Operator::Instance::InputPort; use SPL::Operator::Instance::OutputAttribute; use SPL::Operator::Instance::OutputPort; use SPL::Operator::Instance::Parameter; use SPL::Operator::Instance::StateVariable; use SPL::Operator::Instance::TupleValue; use SPL::Operator::Instance::Window; 
sub main::generate($$) {
   my ($xml, $signature) = @_;  
   print "// $$signature\n";
   my $model = SPL::Operator::Instance::OperatorInstance->new($$xml);
   unshift @INC, dirname ($model->getContext()->getOperatorDirectory()) . "/../impl/nl/include";
   $SPL::CodeGenHelper::verboseMode = $model->getContext()->isVerboseModeOn();
   print '/*', "\n";
   print '==================================================================================', "\n";
   print '                       RACING IBM STREAMS ON LINEAR ROAD', "\n";
   print '                       *********************************', "\n";
   print 'This file contains the IBM Streams C++ operator code for feeding the simulated', "\n";
   print 'data set into the processing logic of the Linear Road Streams application.', "\n";
   print 'The data feeder code provided by the LR team is faithfully wrapped', "\n";
   print 'inside this operator\'s process method that does a typical source operator function.', "\n";
   print "\n";
   print 'Linear Road analytics offers one particular method to evaluate a Streaming', "\n";
   print 'Middleware product by measuring its key performance indicators.', "\n";
   print "\n";
   print 'In order to understand the code below, one should have a good grounding in', "\n";
   print 'the imaginary scenario on which the Linear Road is based upon.', "\n";
   print 'If necessary, please read about that first before proceeding with the code below.', "\n";
   print "\n";
   print 'http://www.cs.brandeis.edu/~linearroad/ ', "\n";
   print "\n";
   print 'First created on: Aug/19/2015', "\n";
   print 'Last modified on: Oct/14/2015', "\n";
   print '==================================================================================', "\n";
   print '*/', "\n";
   print '/* Additional includes go here */', "\n";
   print '#include <stdlib.h>', "\n";
   print '#include <string>', "\n";
   print '#include <iostream>', "\n";
   print '#include <fstream>', "\n";
   print '#include <time.h>', "\n";
   print '#include <string.h>', "\n";
   print "\n";
   print '// Include the header file provided by the the Linear Road data driver.', "\n";
   print '#include "LRDataProvider.h"', "\n";
   print "\n";
   print 'using namespace std;', "\n";
   print "\n";
   SPL::CodeGen::implementationPrologue($model);
   print "\n";
   print "\n";
   print '// Constructor', "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::MY_OPERATOR()', "\n";
   print '{', "\n";
   print '    // Initialization code goes here', "\n";
   print '	initDelay = 0;', "\n";
   print '	lrDataFile = "";', "\n";
   print '	dataReceiver = "";', "\n";
   print '	startingExpressway = 0;', "\n";
   print '	endingExpressway = 0;', "\n";
   print '	', "\n";
   print '	// Read the user supplied operator parameters done at the time of the operation invocation inside the SPL file.', "\n";
   print '	// All our operator parameters are mandatory. Hence, there is no need to check whether the', "\n";
   print '	// getParameterByName method returns a non-null value or not.', "\n";
   print '	';
       	my $dataFileParam = $model->getParameterByName("dataFile");	
           print ("lrDataFile = " . $dataFileParam->getValueAt(0)->getCppExpression() . ";\n");
           
       	my $initDelayParam = $model->getParameterByName("initDelay");	
           print ("initDelay = " . $initDelayParam->getValueAt(0)->getCppExpression() . ";\n");
           
   		# This one is is defined in the operator model to be a CustomLiteral.
   		# Hence, we have to use getSPLExpression to get the literal and then include it within double quotes. 
           my $dataReceiverParam = $model->getParameterByName("dataReceiver");	
           print ("dataReceiver = \"" . $dataReceiverParam->getValueAt(0)->getSPLExpression() . "\";\n");
           
       	my $startingExpresswayParam = $model->getParameterByName("startingExpressway");	
           print ("startingExpressway = " . $startingExpresswayParam->getValueAt(0)->getCppExpression() . ";\n");
           
       	my $endingExpresswayParam = $model->getParameterByName("endingExpressway");	
           print ("endingExpressway = " . $endingExpresswayParam->getValueAt(0)->getCppExpression() . ";\n");
       
   print "\n";
   print '    ', "\n";
   print '    // Data receiver param must be either "tcp" or "kafka" or "none".', "\n";
   print '    // Use "none" to disable the LinearRoad data feeder logic and read the data using', "\n";
   print '    // a different operator such as FileSource for a fast reading/LR-logic-debugging purposes.', "\n";
   print '    if ((dataReceiver != "tcp") && (dataReceiver != "kafka") && (dataReceiver != "none")) {', "\n";
   print '    	SPLAPPTRC(L_ERROR, "dataReceiver operator parameter must either be \\"tcp\\" or \\"kafka\\" or \\"none\\".", "_X_DF");', "\n";
   print '		// Let us abort this operator.', "\n";
   print '		SPL::Functions::Utility::abort("", 0);', "\n";
   print '    }', "\n";
   print '}', "\n";
   print "\n";
   print '// Destructor', "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::~MY_OPERATOR() ', "\n";
   print '{', "\n";
   print '    // Finalization code goes here', "\n";
   print '}', "\n";
   print "\n";
   print '// Notify port readiness', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::allPortsReady() ', "\n";
   print '{', "\n";
   print '    // Notifies that all ports are ready. No tuples should be submitted before', "\n";
   print '    // this. Source operators can use this method to spawn threads.', "\n";
   print '      createThreads(1); // Create source thread', "\n";
   print '}', "\n";
   print ' ', "\n";
   print '// Notify pending shutdown', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::prepareToShutdown() ', "\n";
   print '{', "\n";
   print '    // This is an asynchronous call', "\n";
   print '}', "\n";
   print "\n";
   print '// Processing for source and threaded operators', "\n";
   print '// This method doesn\'t use any of the data feeder logic provided by the', "\n";
   print '// Linear Road data feeder C++ library code. All the logic inside this', "\n";
   print '// method was bulit by the IBM Streams team to create a similar behavior as', "\n";
   print '// in the LR data feeder to send data in bursts. If you want to use the', "\n";
   print '// original LR data feeder code for some reason, you can refer to the', "\n";
   print '// commented out method that appears below this method.', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(uint32_t idx)', "\n";
   print '{', "\n";
   print '	SPLAPPTRC(L_ERROR, "******* START OF LINEAR ROAD PROCESSING (data feeder) *******", "_X_DF");	', "\n";
   print '	', "\n";
   print '	if (dataReceiver == "none") {', "\n";
   print '		// User doesn\'t want to read using the Linear Road data feeded logic.', "\n";
   print '		// This is usually done for reading the LR data via a different operator such as the', "\n";
   print '		// FileSource to make the debugging of the core LR SPL logic much faster.', "\n";
   print '		SPLAPPTRC(L_ERROR, "User opted for not using the Linear Road data feeder logic with \\"none\\" option.", "X_DF");', "\n";
   print '		SPLAPPTRC(L_ERROR, "******* END OF LINEAR ROAD PROCESSING (data feeder) *******", "X_DF");', "\n";
   print '		return;', "\n";
   print '	}', "\n";
   print '	', "\n";
   print '	// Open the file from where have to read the LR traffic data.', "\n";
   print '	ifstream lrFile(lrDataFile.c_str());', "\n";
   print '	', "\n";
   print '	if (lrFile.is_open() == false) {', "\n";
   print '		SPLAPPTRC(L_ERROR, "Unable to open the LR Data file (" + lrDataFile + ").", "X_DF");', "\n";
   print '		SPLAPPTRC(L_ERROR, "******* END OF LINEAR ROAD PROCESSING (data feeder) *******", "X_DF");', "\n";
   print '		return;', "\n";
   print '	}', "\n";
   print '	', "\n";
   print '	// If user has asked us to do an initDelay, let us wait briefly now before proceeding.', "\n";
   print '	if (initDelay > 0) {', "\n";
   print '		sleep(initDelay);', "\n";
   print '	}', "\n";
   print '	', "\n";
   print '	int ts = 0;', "\n";
   print '	uint64 submittedTuplesTotalCnt = 0;', "\n";
   print '	uint64 previousTotalOfSubmittedTuples = 0;', "\n";
   print '	uint64 numberOfTuplesSubmittedInThisTimeBlock = 0;', "\n";
   print '	string lrEventDataToBeSent = "";', "\n";
   print '	time_t startTime;', "\n";
   print '	time_t currentTime;', "\n";
   print '	time(&startTime);', "\n";
   print "\n";
   print '	// A typical Source operator implementation will loop until shutdown.', "\n";
   print '	// We will stay here in this loop and keep feeding the', "\n";
   print '	// Linear Road data to the rest of the Streams application topology. ', "\n";
   print '	while(!getPE().getShutdownRequested()) {', "\n";
   print '		// Get a random number between 1 and 2', "\n";
   print '		srand(time(NULL));			  ', "\n";
   print '		int s =  (int) ((((double) rand()) / RAND_MAX) * 1) + 1;', "\n";
   print '		// Sleep s seconds.', "\n";
   print '		// Sleeping here allows us to send a burst of data to the downstream stream processing components and', "\n";
   print '		// that will test the ability to handle periodic bursts. However, it also gives a chance for', "\n";
   print '		// for those downstream components to be idle for several seconds routinely. This will help the Java based', "\n";
   print '		// products enough time to do garbage collection thereby hiding certain sluggishness. ', "\n";
   print '		//', "\n";
   print '		// In addition, it would also be necessary to send a continuous stream of data at high volumes without', "\n";
   print '		// any sleep and test whether the downstream stream processing components can sustain that continuous load.', "\n";
   print '		// But, the designers of the Linear Road DataFeeder didn\'t do that for some unknown reasons.', "\n";
   print '		//	', "\n";
   print '		// sleep(s);', "\n";
   print '		SPL::Functions::Utility::block((float64)s);', "\n";
   print '		', "\n";
   print '		// Stay in a loop and start sending the data from where we left off earlier until the current simulation second.', "\n";
   print '		while(lrFile.eof() == false) {', "\n";
   print '			// If there is pending data from the previous file read still waiting to be sent,', "\n";
   print '			// we can first deal with that pending data before reading a new row from the file.', "\n";
   print '			if (lrEventDataToBeSent.length() == 0) {', "\n";
   print '				// Read the next row from the file.', "\n";
   print '				getline(lrFile, lrEventDataToBeSent);', "\n";
   print '				', "\n";
   print '				// If we encounter any empty lines, skip them.', "\n";
   print '				if (lrEventDataToBeSent.length() == 0) {', "\n";
   print '					// continue with the file reading inner while loop.', "\n";
   print '					continue;', "\n";
   print '				}', "\n";
   print '			}', "\n";
   print "\n";
   print '			// In the row we read from the LR data file, there should be 15 tokens each', "\n";
   print '			// separated by a comma character. Let us parse it now.', "\n";
   print '			int32 values[15] = {0};', "\n";
   print '			int32 idx = 0;', "\n";
   print '			char eventStr[540] = {0x0};', "\n";
   print "\n";
   print '			// C strtok is not thread safe when I fuse multiple data feeders. Hence, I had to write my own parser.', "\n";
   print '			// Don\'t use the following block of code when multiple data feeders are fused. That causes, strtok to corrupt memory.', "\n";
   print '			/*', "\n";
   print '			strcpy(eventStr, lrEventDataToBeSent.c_str());', "\n";
   print '			char *token = strtok(eventStr, ",");', "\n";
   print '			', "\n";
   print '			while(token != NULL) {', "\n";
   print '				values[idx++] = atoi(token);', "\n";
   print '				token = strtok(NULL, ",");', "\n";
   print '			}', "\n";
   print '			', "\n";
   print '			// Check if we parsed all the 15 tokens from that row.', "\n";
   print '			if (idx < 15) {', "\n";
   print '				// This was a malformed row with less than 15 tokens in it.', "\n";
   print '				SPLAPPTRC(L_ERROR, "Invalid event found in file: Token count=" << idx << ", event data=" << ', "\n";
   print '					lrEventDataToBeSent << ", event C str=" << string(eventStr), "_X_DF");', "\n";
   print '				lrEventDataToBeSent.clear();', "\n";
   print '				// Continue with the inner while loop to read the next row.', "\n";
   print '				continue;', "\n";
   print '			}', "\n";
   print '			*/', "\n";
   print '			', "\n";
   print '			// Let us write our own CSV parser in C.', "\n";
   print '			strcpy(eventStr, lrEventDataToBeSent.c_str());', "\n";
   print '			int32 len = lrEventDataToBeSent.length();', "\n";
   print '			int32 loopCnt = 0;', "\n";
   print '			char token[50] = {0x0};', "\n";
   print '			int32 tokenLen = 0;', "\n";
   print '			', "\n";
   print '			for (loopCnt = 0; loopCnt < len; loopCnt++) {', "\n";
   print '				if (eventStr[loopCnt] == \',\') {', "\n";
   print '					// Comma found', "\n";
   print '					token[tokenLen] = 0x0;', "\n";
   print '					// Convert this token to an integer and store it.', "\n";
   print '					values[idx++] = atoi(token);', "\n";
   print '					tokenLen = 0;', "\n";
   print '				} else {', "\n";
   print '					// Keep collecting the characters for the current token being parsed.', "\n";
   print '					token[tokenLen++] = eventStr[loopCnt];', "\n";
   print '				}				', "\n";
   print '			}', "\n";
   print '			', "\n";
   print '			// End of string reached. Convert the final token to integer and store it.', "\n";
   print '			token[tokenLen] = 0x0;', "\n";
   print '			values[idx++] = atoi(token);', "\n";
   print '			', "\n";
   print '			// Check if we parsed all the 15 tokens for a given Linear Road event row.', "\n";
   print '			if (idx < 15) {', "\n";
   print '				// This was a malformed row with less than 15 tokens in it.', "\n";
   print '				SPLAPPTRC(L_ERROR, "Invalid event found in file: Token count=" << idx << ", event data=" << ', "\n";
   print '					lrEventDataToBeSent << ", event C str=" << string(eventStr), "_X_DF");', "\n";
   print '				lrEventDataToBeSent.clear();', "\n";
   print '				// Continue with the inner while loop to read the next row.', "\n";
   print '				continue;', "\n";
   print '			}			', "\n";
   print '			', "\n";
   print '			', "\n";
   print '			// Use this code block for debugging the result from our home grown CSV parser.', "\n";
   print '			/*', "\n";
   print '			if (endingExpressway == 9) {', "\n";
   print '				cout << "Row=" << lrEventDataToBeSent << endl;', "\n";
   print '				', "\n";
   print '				for (loopCnt = 0; loopCnt < 15; loopCnt++) {', "\n";
   print '					if (loopCnt > 0) {', "\n";
   print '						cout << ",";', "\n";
   print '					}', "\n";
   print '				', "\n";
   print '					cout << values[loopCnt];', "\n";
   print '				}', "\n";
   print '			', "\n";
   print '				cout << endl;', "\n";
   print '			}', "\n";
   print '			*/', "\n";
   print '			', "\n";
   print '			// There are multiple data feeders each reading the same LR data file.', "\n";
   print '			// Each data feeder is configured to send data only for a particular range of expressways.', "\n";
   print '			// For type 0 and type 3 events, we can apply that expressway range filter.', "\n";
   print '			// For type 2 events, there is no expressway field. Hence, it will get sent to', "\n";
   print '			// all the feeders and hence there will be duplicate account balance readings.', "\n";
   print '			if ((values[0] == 0 || values[0] == 3) && ', "\n";
   print '				(values[4] < startingExpressway || values[4] > endingExpressway)) {', "\n";
   print '				// This car event is not in this data feeder\'s expressway range.', "\n";
   print '				// Skip sending this car event to this data feeder.', "\n";
   print '				lrEventDataToBeSent.clear();', "\n";
   print '				continue;', "\n";
   print '			}', "\n";
   print '			', "\n";
   print '			// Check if this event belongs to the current simulation second.', "\n";
   print '			time(&currentTime);', "\n";
   print '			//Calculate the elapsed time in second', "\n";
   print '			ts = (int)difftime(currentTime, startTime);', "\n";
   print '			', "\n";
   print '			if (values[1] > ts) {', "\n";
   print '				// This event is to be sent at a future time.', "\n";
   print '				// Let us wait for that time to arrive.', "\n";
   print '				// Break out of the inner while loop so that it can go back to the outer while loop.', "\n";
   print '				break;', "\n";
   print '			}			', "\n";
   print '			', "\n";
   print '			// We can feed the LR events either to a TCP capable built-in/primitive', "\n";
   print '			// operator or to a kafa sink from here.', "\n";
   print '			if (dataReceiver == "tcp") {', "\n";
   print '				OPort0Type oTuple0;', "\n";
   print '				// If we are here, that means this data feed will be received via a TCP capable', "\n";
   print '				// Streams operator. We can form a full tuple with non-string attributes and send it.', "\n";
   print '				// Let us now populate the IBM Streams tuple attributes and send it away.', "\n";
   print '				ValueHandle handle0 = oTuple0.getAttributeValue(0);', "\n";
   print '				int32 & eventType = handle0;', "\n";
   print '				// We will assign this attribute to a value we got from the data provider.', "\n";
   print '				eventType = values[0];', "\n";
   print "\n";
   print '				// Do a similar value assignment for the remaining attributes.', "\n";
   print '				ValueHandle handle1 = oTuple0.getAttributeValue(1);', "\n";
   print '				int32 & eventTimestamp = handle1;', "\n";
   print '				eventTimestamp = values[1];', "\n";
   print '				  ', "\n";
   print '				ValueHandle handle2 = oTuple0.getAttributeValue(2);', "\n";
   print '				int32 & vehicleId = handle2;', "\n";
   print '				vehicleId = values[2];', "\n";
   print "\n";
   print '				ValueHandle handle3 = oTuple0.getAttributeValue(3);', "\n";
   print '				int32 & vehicleSpeed = handle3;', "\n";
   print '				vehicleSpeed = values[3];', "\n";
   print "\n";
   print '				ValueHandle handle4 = oTuple0.getAttributeValue(4);', "\n";
   print '				int32 & expressWayNumber = handle4;', "\n";
   print '				expressWayNumber = values[4];', "\n";
   print "\n";
   print '				ValueHandle handle5 = oTuple0.getAttributeValue(5);', "\n";
   print '				int32 & laneNumber = handle5;', "\n";
   print '				laneNumber = values[5];', "\n";
   print "\n";
   print '				ValueHandle handle6 = oTuple0.getAttributeValue(6);', "\n";
   print '				int32 & directionIndicator = handle6;	', "\n";
   print '				directionIndicator = values[6];', "\n";
   print "\n";
   print '				ValueHandle handle7 = oTuple0.getAttributeValue(7);', "\n";
   print '				int32 & segmentId = handle7;', "\n";
   print '				segmentId = values[7];', "\n";
   print '				  ', "\n";
   print '				ValueHandle handle8 = oTuple0.getAttributeValue(8);', "\n";
   print '				int32 & vehiclePosition = handle8;', "\n";
   print '				vehiclePosition = values[8];', "\n";
   print '				  ', "\n";
   print '				ValueHandle handle9 = oTuple0.getAttributeValue(9);', "\n";
   print '				int32 & queryId = handle9;', "\n";
   print '				queryId = values[9];', "\n";
   print "\n";
   print '				ValueHandle handle10 = oTuple0.getAttributeValue(10);', "\n";
   print '				int32 & startingSegment = handle10;', "\n";
   print '				startingSegment = values[10];', "\n";
   print "\n";
   print '				ValueHandle handle11 = oTuple0.getAttributeValue(11);', "\n";
   print '				int32 & endingSegment = handle11;', "\n";
   print '				endingSegment = values[11];', "\n";
   print '				  ', "\n";
   print '				ValueHandle handle12 = oTuple0.getAttributeValue(12);', "\n";
   print '				int32 & dayOfWeek = handle12;', "\n";
   print '				dayOfWeek = values[12];', "\n";
   print '				  ', "\n";
   print '				ValueHandle handle13 = oTuple0.getAttributeValue(13);', "\n";
   print '				int32 & minutesOfCurrentDay = handle13;', "\n";
   print '				minutesOfCurrentDay = values[13];', "\n";
   print "\n";
   print '				ValueHandle handle14 = oTuple0.getAttributeValue(14);', "\n";
   print '				int32 & dayInThePast = handle14;', "\n";
   print '				dayInThePast = values[14];', "\n";
   print "\n";
   print '				submittedTuplesTotalCnt++;', "\n";
   print '				///// Use the following line to debug the event messages that are being sent out.', "\n";
   print '				///// SPLAPPTRC(L_ERROR, oTuple0, "_X_DF");					  ', "\n";
   print '				// Submit this tuple on the first output port.', "\n";
   print '				submit(oTuple0, 0);', "\n";
   print '				// We can clear the row we read from the file since it is now processed completely.', "\n";
   print '				lrEventDataToBeSent.clear();', "\n";
   print '			} else if (dataReceiver == "kafka") {', "\n";
   print '				OPort1Type oTuple1;', "\n";
   print '				// We will send a string formatted event to Kafka since it can\'t deal with non-string values.', "\n";
   print '				// We can now populate the topic and the message attributes needed by the kafka producer operator.', "\n";
   print '				ValueHandle handle0 = oTuple1.getAttributeValue(0);', "\n";
   print '				rstring & kafkaMessage = handle0;', "\n";
   print '				// We will assign this attribute to a value we received from the LR data provider.', "\n";
   print '				kafkaMessage = lrEventDataToBeSent;', "\n";
   print '				submittedTuplesTotalCnt++;', "\n";
   print "\n";
   print '				///// Use the following line to debug the event messages that are being sent out.', "\n";
   print '				///// Following console print will allow us to do an exact comparison between', "\n";
   print '				///// what gets sent from the LR data driver and the original contents present in the data set file.', "\n";
   print '				///// Uncomment the following two lines as per your need.', "\n";
   print '				// ', "\n";
   print '				// Printing via cout will help us to get the exact dump of what is being sent out.', "\n";
   print '				// We can simply compare that dump with the original data file to see if every event is', "\n";
   print '				// going out in the exact same time order.', "\n";
   print '				//', "\n";
   print '				///// cout << str;', "\n";
   print '				///// SPLAPPTRC(L_ERROR, oTuple1, "_X_DF");    				  ', "\n";
   print '				  ', "\n";
   print '				// We can submit it now on the second output port.', "\n";
   print '				submit(oTuple1, 1);', "\n";
   print '				// We can clear the row we read from the file since it is now processed completely.', "\n";
   print '				lrEventDataToBeSent.clear();				  ', "\n";
   print '			} ', "\n";
   print '		} // End of the inner while loop.', "\n";
   print '				', "\n";
   print '		numberOfTuplesSubmittedInThisTimeBlock = submittedTuplesTotalCnt - previousTotalOfSubmittedTuples;', "\n";
   print '		previousTotalOfSubmittedTuples = submittedTuplesTotalCnt;', "\n";
   print "\n";
   print '		SPLAPPTRC(L_ERROR, ts << " seconds have passed. SE=" << startingExpressway << ", EE=" << endingExpressway << ', "\n";
   print '			". Number of tuples submitted in this time block=" << numberOfTuplesSubmittedInThisTimeBlock <<', "\n";
   print '			", Total number of tuples submitted thus far=" << submittedTuplesTotalCnt, "_X_DF");', "\n";
   print '		', "\n";
   print '		if(lrFile.eof() == true) {', "\n";
   print '			SPLAPPTRC(L_ERROR, "End of file reached.", "_X_DF");', "\n";
   print '			break;', "\n";
   print '		}		', "\n";
   print '	} // End of the outer while loop.', "\n";
   print '	', "\n";
   print '	lrFile.close();', "\n";
   print '	SPLAPPTRC(L_ERROR, "******* END OF LINEAR ROAD PROCESSING (data feeder) *******", "X_DF");	', "\n";
   print '}', "\n";
   print "\n";
   print '/*', "\n";
   print '// ************************   IMPORTANT COMMENTED OUT METHOD  *****************************************', "\n";
   print '// On Oct/08/2015, Senthil commented out this entire method and created a new process method as ', "\n";
   print '// shown above. The original Linear Road Data Feeder code takes much more than 3 hours to emit the', "\n";
   print '// 3 hours worth of traffic data. For bigger data sets, it even takes a lot more than 3 hours.', "\n";
   print '// ', "\n";
   print '// Looking through their code, it has a logic that is too elaborative for the required task of ', "\n";
   print '// sending the LR events in bursts rather than continuously. It was decided to ignore their data feeder', "\n";
   print '// code and write our own method as shown above to perform a similar logic as the original LR data feeder', "\n";
   print '// code but with a much simpler file reading code. If someone wants to use LR data feeder code for', "\n";
   print '// emitting the traffic data, then the method above can be commented out and the following', "\n";
   print '// method can be uncommented and reinstated.', "\n";
   print '// ***************************************************************************************************', "\n";
   print '// Processing for source and threaded operators   ', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(uint32_t idx)', "\n";
   print '{', "\n";
   print '	SPLAPPTRC(L_ERROR, "******* START OF LINEAR ROAD PROCESSING (data feeder) *******", "_X_DF");	', "\n";
   print '	', "\n";
   print '	if (dataReceiver == "none") {', "\n";
   print '		// User doesn\'t want to read using the Linear Road data feeded logic.', "\n";
   print '		// This is usually done for reading the LR data via a different operator such as the', "\n";
   print '		// FileSource to make the debugging of the core LR SPL logic much faster.', "\n";
   print '		SPLAPPTRC(L_ERROR, "User opted for not using the Linear Road data feeder logic with \\"none\\" option.", "X_DF");', "\n";
   print '		SPLAPPTRC(L_ERROR, "******* END OF LINEAR ROAD PROCESSING (data feeder) *******", "X_DF");', "\n";
   print '		return;', "\n";
   print '	}', "\n";
   print '	', "\n";
   print '	// If user has asked us to do an initDelay, let us wait briefly now before proceeding.', "\n";
   print '	if (initDelay > 0) {', "\n";
   print '		sleep(initDelay);', "\n";
   print '	}', "\n";
   print '	', "\n";
   print '	// A typical Source operator implementation will loop until shutdown', "\n";
   print '	pthread_mutex_t  mutex_lock = PTHREAD_MUTEX_INITIALIZER;', "\n";
   print '	char* dataFile = (char *)lrDataFile.c_str();', "\n";
   print '	  ', "\n";
   print '	// Instantiate and initialize the Linear Road data provider.', "\n";
   print '	CLRDataProvider* provider = new CLRDataProvider();', "\n";
   print '	SPLAPPTRC(L_ERROR,', "\n";
   print '		"Initializing the Linear Road data provider to read data from " << ', "\n";
   print '		dataFile << " and send it via " << dataReceiver << ".", "_X_DF");', "\n";
   print '	int32_t ret = provider->Initialize(dataFile, 10000, &mutex_lock);', "\n";
   print '	  ', "\n";
   print '	if (ret != SUCCESS) {	', "\n";
   print '		errorHandler(ret);', "\n";
   print '		// Let us abort this operator.', "\n";
   print '		SPL::Functions::Utility::abort("", 0);', "\n";
   print '		return;', "\n";
   print '	}', "\n";
   print '	  ', "\n";
   print '	// Ask the provider to prepare the data.', "\n";
   print '	if(provider->PrepareData(provider) != SUCCESS) {', "\n";
   print '		SPLAPPTRC(L_ERROR, "Call to the provider\'s PrepareData method failed.", "_X_DF");', "\n";
   print '		delete provider;', "\n";
   print '		errorHandler(ret);', "\n";
   print '		// Let us abort this operator.', "\n";
   print '		SPL::Functions::Utility::abort("", 0);', "\n";
   print '		return;    		  ', "\n";
   print '	}', "\n";
   print '	  ', "\n";
   print '	int	nTuplesRead = 0;', "\n";
   print '	int	nMaxTuples  = 100;', "\n";
   print '	//Allocate caller\'s buffer', "\n";
   print '	LPTuple lpTuples = new LRTuple[nMaxTuples ];    	  			', "\n";
   print '	int seconds = 0;', "\n";
   print '	uint64 submittedTuplesTotalCnt = 0;', "\n";
   print '	', "\n";
   print '	// We will stay here in this loop and keep feeding the', "\n";
   print '	// Linear Road data to the rest of the Streams application topology. ', "\n";
   print '    while(!getPE().getShutdownRequested()) {', "\n";
   print '    	  // Get a random number between 5 and 15', "\n";
   print '    	  srand(time(NULL));			  ', "\n";
   print '    	  int s =  (int) ((((double) rand())/ RAND_MAX) * 10) + 5;', "\n";
   print '    	  // Sleep s seconds.', "\n";
   print '    	  // Sleeping here allows us to send a burst of data to the downstream stream processing components and', "\n";
   print '    	  // that will test the ability to handle periodic bursts. However, it also gives a chance for', "\n";
   print '    	  // for those downstream components to be idle for several seconds routinely. This will help the Java based', "\n";
   print '    	  // products enough time to do garbage collection thereby hiding certain sluggishness. ', "\n";
   print '    	  //', "\n";
   print '    	  // In addition, it would also be necessary to send a continuous stream of data at high volumes without', "\n";
   print '    	  // any sleep and test whether the downstream stream processing components can sustain that continuous load.', "\n";
   print '    	  // But, the designers of the Linear Road DataFeeder didn\'t do that for some unknown reasons.', "\n";
   print '    	  //', "\n";
   print '    	  sleep(s);', "\n";
   print '    	  int32_t ret = 0;', "\n";
   print '    	  int64_t eventCnt = 0;', "\n";
   print "\n";
   print '    	  for(;;) {', "\n";
   print '    		  //Get the available data', "\n";
   print '    		  ret = provider->GetData(lpTuples, nMaxTuples, nTuplesRead);', "\n";
   print "\n";
   print '    		  if (ret < 0) {', "\n";
   print '    			  //Handle erros including eof', "\n";
   print '    			  errorHandler(ret);', "\n";
   print '    			  break;', "\n";
   print '    		  }', "\n";
   print "\n";
   print '    		  if (nTuplesRead == 0) {', "\n";
   print '    			  //No tuple available', "\n";
   print '    			  break;', "\n";
   print '    		  }', "\n";
   print '    	  					', "\n";
   print '    		  // Iterate over the data fetched from the provider and send it for further downstream processing.', "\n";
   print '    		  for(int i = 0; i < nTuplesRead; i++) {', "\n";
   print '    			  eventCnt++;', "\n";
   print "\n";
   print '    			  // We can feed the LR events either to a TCP capable built-in/primitive', "\n";
   print '    			  // operator or to a kafa sink from here.', "\n";
   print '    			  if (dataReceiver == "tcp") {', "\n";
   print '    				  OPort0Type oTuple0;', "\n";
   print '					  // If we are here, that means this data feed will be received via a TCP capable', "\n";
   print '					  // Streams operator. We can form a full tuple with non-string attributes and send it.', "\n";
   print '					  // Let us now populate the IBM Streams tuple attributes and send it away.', "\n";
   print '					  ValueHandle handle0 = oTuple0.getAttributeValue(0);', "\n";
   print '					  int32 & eventType = handle0;', "\n";
   print '					  // We will assign this attribute to a value we got from the data provider.', "\n";
   print '					  eventType = lpTuples[i].m_iType;', "\n";
   print '	', "\n";
   print '					  // Do a similar value assignment for the remaining attributes.', "\n";
   print '					  ValueHandle handle1 = oTuple0.getAttributeValue(1);', "\n";
   print '					  int32 & eventTimestamp = handle1;', "\n";
   print '					  eventTimestamp = lpTuples[i].m_iTime;', "\n";
   print '					  ', "\n";
   print '					  ValueHandle handle2 = oTuple0.getAttributeValue(2);', "\n";
   print '					  int32 & vehicleId = handle2;', "\n";
   print '					  vehicleId = lpTuples[i].m_iVid;', "\n";
   print '	', "\n";
   print '					  ValueHandle handle3 = oTuple0.getAttributeValue(3);', "\n";
   print '					  int32 & vehicleSpeed = handle3;', "\n";
   print '					  vehicleSpeed = lpTuples[i].m_iSpeed;', "\n";
   print '	', "\n";
   print '					  ValueHandle handle4 = oTuple0.getAttributeValue(4);', "\n";
   print '					  int32 & expressWayNumber = handle4;', "\n";
   print '					  expressWayNumber = lpTuples[i].m_iXway;', "\n";
   print '	', "\n";
   print '					  ValueHandle handle5 = oTuple0.getAttributeValue(5);', "\n";
   print '					  int32 & laneNumber = handle5;', "\n";
   print '					  laneNumber = lpTuples[i].m_iLane;', "\n";
   print '	', "\n";
   print '					  ValueHandle handle6 = oTuple0.getAttributeValue(6);', "\n";
   print '					  int32 & directionIndicator = handle6;', "\n";
   print '					  directionIndicator = lpTuples[i].m_iDir;', "\n";
   print '	', "\n";
   print '					  ValueHandle handle7 = oTuple0.getAttributeValue(7);', "\n";
   print '					  int32 & segmentId = handle7;', "\n";
   print '					  segmentId = lpTuples[i].m_iSeg;', "\n";
   print '					  ', "\n";
   print '					  ValueHandle handle8 = oTuple0.getAttributeValue(8);', "\n";
   print '					  int32 & vehiclePosition = handle8;', "\n";
   print '					  vehiclePosition = lpTuples[i].m_iPos;', "\n";
   print '					  ', "\n";
   print '					  ValueHandle handle9 = oTuple0.getAttributeValue(9);', "\n";
   print '					  int32 & queryId = handle9;', "\n";
   print '					  queryId = lpTuples[i].m_iQid;', "\n";
   print '	', "\n";
   print '					  ValueHandle handle10 = oTuple0.getAttributeValue(10);', "\n";
   print '					  int32 & startingSegment = handle10;', "\n";
   print '					  startingSegment = lpTuples[i].m_iSinit;', "\n";
   print '	', "\n";
   print '					  ValueHandle handle11 = oTuple0.getAttributeValue(11);', "\n";
   print '					  int32 & endingSegment = handle11;', "\n";
   print '					  endingSegment = lpTuples[i].m_iSend;', "\n";
   print '					  ', "\n";
   print '					  ValueHandle handle12 = oTuple0.getAttributeValue(12);', "\n";
   print '					  int32 & dayOfWeek = handle12;', "\n";
   print '					  dayOfWeek = lpTuples[i].m_iDow;', "\n";
   print '					  ', "\n";
   print '					  ValueHandle handle13 = oTuple0.getAttributeValue(13);', "\n";
   print '					  int32 & minutesOfCurrentDay = handle13;', "\n";
   print '					  minutesOfCurrentDay = lpTuples[i].m_iTod;', "\n";
   print '	', "\n";
   print '					  ValueHandle handle14 = oTuple0.getAttributeValue(14);', "\n";
   print '					  int32 & dayInThePast = handle14;', "\n";
   print '					  dayInThePast = lpTuples[i].m_iDay;', "\n";
   print "\n";
   print '    				  ///// Use the following line to debug the event messages that are being sent out.', "\n";
   print '    				  ///// SPLAPPTRC(L_ERROR, oTuple0, "_X_DF");					  ', "\n";
   print '					  ', "\n";
   print '					  // Submit this tuple on the first output port.', "\n";
   print '					  submit(oTuple0, 0);', "\n";
   print '					  submittedTuplesTotalCnt++;', "\n";
   print '					  // Continue with the next iteration of the for loop.', "\n";
   print '					  continue;', "\n";
   print '    			  } else if (dataReceiver == "kafka") {', "\n";
   print '    				  OPort1Type oTuple1;', "\n";
   print '    				  // We will send a string formatted event to Kafka since it can\'t deal with non-string values.', "\n";
   print '    				  char* str = lpTuples[i].ToString();', "\n";
   print '        			             			     ', "\n";
   print '    				  // We can now populate the topic and the message attributes needed by the kafka producer operator.', "\n";
   print '    				  ValueHandle handle0 = oTuple1.getAttributeValue(0);', "\n";
   print '    				  rstring & kafkaMessage = handle0;', "\n";
   print '    				  // We will assign this attribute to a value we received from the LR data provider.', "\n";
   print '    				  kafkaMessage = string(str);', "\n";
   print '    				  ', "\n";
   print '    				  ///// Use the following line to debug the event messages that are being sent out.', "\n";
   print '    				  ///// Following console print will allow us to do an exact comparison between', "\n";
   print '    				  ///// what gets sent from the LR data driver and the original contents present in the data set file.', "\n";
   print '    				  ///// Uncomment the following two lines as per your need.', "\n";
   print '    				  // ', "\n";
   print '    				  // Printing via cout will help us to get the exact dump of what is being sent out.', "\n";
   print '    				  // We can simply compare that dump with the original data file to see if every event is', "\n";
   print '    				  // going out in the exact same time order.', "\n";
   print '    				  //', "\n";
   print '    				  ///// cout << str;', "\n";
   print '    				  ///// SPLAPPTRC(L_ERROR, oTuple1, "_X_DF");    				  ', "\n";
   print '    				  ', "\n";
   print '    				  // We must clean up the object we got back from the LR data provider. ', "\n";
   print '    				  delete str;    			     ', "\n";
   print '    				  // We can submit it now on the second output port.', "\n";
   print '    				  submit(oTuple1, 1);', "\n";
   print '    				  submittedTuplesTotalCnt++;', "\n";
   print '    				  // Continue with the next iteration of the for loop.', "\n";
   print '    				  continue;', "\n";
   print '    			  } ', "\n";
   print '    		  } // End of the for loop iterating over the lpTuples array.', "\n";
   print "\n";
   print '    		  if (nTuplesRead < nMaxTuples) {', "\n";
   print '    			  //Last tuple has been read', "\n";
   print '    			  break;', "\n";
   print '    		  }', "\n";
   print '    	  } // End of the outer for loop. ', "\n";
   print "\n";
   print '    	  if (ret < SUCCESS) {				', "\n";
   print '    		  break;', "\n";
   print '    	  }', "\n";
   print "\n";
   print '    	  seconds += s;', "\n";
   print '    	  // SPLAPPTRC(L_ERROR, seconds << " seconds have passed. Number of tuples submitted=" << submittedTuplesTotalCnt, "_X_DF");', "\n";
   print '      } // End of while loop', "\n";
   print "\n";
   print '      //Uninitialize the provider', "\n";
   print '      SPLAPPTRC(L_ERROR, "Uninitializing the Linear Road data provider ...", "_X_DF");', "\n";
   print '      provider->Uninitialize();', "\n";
   print '      delete provider;', "\n";
   print '      delete [] lpTuples;', "\n";
   print '      SPLAPPTRC(L_ERROR, "******* END OF LINEAR ROAD PROCESSING (data feeder) *******", "X_DF");', "\n";
   print '}', "\n";
   print '*/', "\n";
   print "\n";
   print '// Tuple processing for mutating ports ', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Tuple & tuple, uint32_t port)', "\n";
   print '{', "\n";
   print '    // Sample submit code', "\n";
   print '    /* ', "\n";
   print '      submit(otuple, 0); // submit to output port 0', "\n";
   print '    */', "\n";
   print '}', "\n";
   print "\n";
   print '// Tuple processing for non-mutating ports', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Tuple const & tuple, uint32_t port)', "\n";
   print '{', "\n";
   print '    // Sample submit code', "\n";
   print '    /* ', "\n";
   print '      OPort0Type otuple;', "\n";
   print '      submit(otuple, 0); // submit to output port 0', "\n";
   print '    */', "\n";
   print '}', "\n";
   print "\n";
   print '// Punctuation processing', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Punctuation const & punct, uint32_t port)', "\n";
   print '{', "\n";
   print '    /*', "\n";
   print '      if(punct==Punctuation::WindowMarker) {', "\n";
   print '        // ...;', "\n";
   print '      } else if(punct==Punctuation::FinalMarker) {', "\n";
   print '        // ...;', "\n";
   print '      }', "\n";
   print '    */', "\n";
   print '}', "\n";
   print "\n";
   print '// Error handler for the Linear Road data provider', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::errorHandler(int32_t nErrorCode)', "\n";
   print '{', "\n";
   print '	switch(nErrorCode)', "\n";
   print '	{', "\n";
   print '		case END_OF_FILE:', "\n";
   print '			{', "\n";
   print '				SPLAPPTRC(L_ERROR, "End of data file", "_X_DF");', "\n";
   print '			}', "\n";
   print '			break;', "\n";
   print '		case ERROR_FILE_NOT_FOUND:', "\n";
   print '			{	', "\n";
   print '				SPLAPPTRC(L_ERROR, "Data file not found. Check data file path name.", "_X_DF");', "\n";
   print '			}', "\n";
   print '			break;', "\n";
   print '		case ERROR_INVALID_FILE:', "\n";
   print '			{', "\n";
   print '				SPLAPPTRC(L_ERROR, "Invalid file handler. Restart the system.", "_X_DF");', "\n";
   print '			}', "\n";
   print '			break;', "\n";
   print '		case ERROR_BUFFER_OVERFLOW:', "\n";
   print '			{', "\n";
   print '				SPLAPPTRC(L_ERROR, "Buffer over flow. Increase the buffer size.", "_X_DF");', "\n";
   print '			}', "\n";
   print '			break;', "\n";
   print '		default:', "\n";
   print '			{', "\n";
   print '				SPLAPPTRC(L_ERROR, "Programming error.", "_X_DF");', "\n";
   print '			}', "\n";
   print '			break;', "\n";
   print '	}', "\n";
   print '}', "\n";
   print "\n";
   SPL::CodeGen::implementationEpilogue($model);
   print "\n";
   print "\n";
   CORE::exit $SPL::CodeGen::USER_ERROR if ($SPL::CodeGen::sawError);
}
1;
